<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器部署记录：可道云</title>
      <link href="/2020/02/15/fu-wu-qi-bu-shu-ji-lu-ke-dao-yun/"/>
      <url>/2020/02/15/fu-wu-qi-bu-shu-ji-lu-ke-dao-yun/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器部署记录：可道云部署"><a href="#服务器部署记录：可道云部署" class="headerlink" title="服务器部署记录：可道云部署"></a>服务器部署记录：可道云部署</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文作为部署记录，以前是利用nginx的php支持部署的，现在发现推荐方案是<code>xampp</code>了，于是给新服务器重新部署了一下。</p><p>官网：<a href="http://kodcloud.com" target="_blank" rel="noopener">http://kodcloud.com</a></p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200215185835128-1516408673.png" alt=""></p><p>很好用的一个网盘<br>很好用的一个网盘<br>很好用的一个网盘<br>不多介绍了  </p><h2 id="XAMPP安装"><a href="#XAMPP安装" class="headerlink" title="XAMPP安装"></a>XAMPP安装</h2><p>安装包下载：<a href="https://sourceforge.net/projects/xampp/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/xampp/files/</a></p><p>下载好之后加上可执行权限，用root运行即可一键安装。</p><p>发现这个就是<code>Apache + MySQL + ProFTPd</code>的组合，运行<code>sudo ./lampp start</code>即可一键启动，还是挺不错的。</p><h2 id="kod下载"><a href="#kod下载" class="headerlink" title="kod下载"></a>kod下载</h2><p>截止发文时间<code>2020-2-15</code>，最新版是<code>4.40</code>。推荐从官网直接下载。</p><p>提醒提前新建一个文件夹执行下面的代码：</p><pre><code>wget http://static.kodcloud.com/update/download/kodexplorer4.40.zipunzip kodexplorer4.40.zipchmod -Rf 777 ./*</code></pre><p>解压放在<code>/opt/lampp/htdocs/</code>下即可，使用<code>http://服务器ip/文件夹名称</code>访问。</p><p>此时已经可以正常使用了。</p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200215184816223-519877718.png" alt=""></p><h2 id="apache监听端口更改"><a href="#apache监听端口更改" class="headerlink" title="apache监听端口更改"></a>apache监听端口更改</h2><p>配置文件在<code>/opt/lampp/etc/httpd.conf</code>，而不是<code>/opt/lampp/apache2/conf/httpd.conf</code>，这一点要注意一下。</p><pre><code>Listen 80</code></pre><p>修改这个端口即可，用<code>sudo ./lampp restart</code>或者<code>sudo ./lampp reloadapache</code>来重启。</p><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>编辑<code>/etc/nginx/conf.d/文件名.conf</code>即可，文件名任意取。</p><pre><code>server {    server_name 要访问的域名;    location / {        proxy_pass 本地服务地址;    }}</code></pre><h2 id="域名配置云加速（减速"><a href="#域名配置云加速（减速" class="headerlink" title="域名配置云加速（减速"></a>域名配置云加速（减速</h2><p><code>cloudflare</code>上加一条A记录即可。</p><h2 id="更新：https支持"><a href="#更新：https支持" class="headerlink" title="更新：https支持"></a>更新：https支持</h2><p>利用Let‘s encrypt即可。</p><pre><code>server {    server_name 要访问的域名;    location / {        proxy_pass 本地服务地址;        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    }    listen 443 ssl; # managed by Certbot    ssl_certificate /etc/letsencrypt/live/要访问的域名/fullchain.pem; # managed by Certbot    ssl_certificate_key /etc/letsencrypt/live/要访问的域名/privkey.pem; # managed by Certbot    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot}server{    listen 80;    server_name 要访问的域名;    add_header Strict-Transport-Security max-age=15768000;    return 301 https://$server_name$request_uri;}</code></pre><p>配置好了用<code>sudo nginx -s reload</code>重载一下nginx，如果nginx没有对证书的访问权限，重启一下nginx。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT (Advanced Level) Practice 1001-1005</title>
      <link href="/2020/02/09/pat-advanced-level-practice-1001-1005/"/>
      <url>/2020/02/09/pat-advanced-level-practice-1001-1005/</url>
      
        <content type="html"><![CDATA[<h1 id="PAT-Advanced-Level-Practice-1001-1005"><a href="#PAT-Advanced-Level-Practice-1001-1005" class="headerlink" title="PAT (Advanced Level) Practice 1001-1005"></a>PAT (Advanced Level) Practice 1001-1005</h1><h2 id="PAT-计算机程序设计能力考试-甲级-练习题"><a href="#PAT-计算机程序设计能力考试-甲级-练习题" class="headerlink" title="PAT 计算机程序设计能力考试 甲级 练习题"></a>PAT 计算机程序设计能力考试 甲级 练习题</h2><h2 id="题库：PTA拼题A官网"><a href="#题库：PTA拼题A官网" class="headerlink" title="题库：PTA拼题A官网"></a>题库：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PTA拼题A官网</a></h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200209214258180-1226431101.png" alt=""></p><p>这是浙大背景的一个计算机考试  </p><p>刷刷题练练手  </p><p>在博客更新题解 每五题更新一次 共155题  </p><h2 id="题目目录"><a href="#题目目录" class="headerlink" title="题目目录"></a>题目目录</h2><blockquote><p>1001 A+B Format (20分)<br>1002 A+B for Polynomials (25分)<br>1003 Emergency (25分)<br>1004 Counting Leaves (30分)<br>1005 Spell It Right (20分)  </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>1001 签到题（格式）<br>1002 签到题（格式）<br>1003 多条最短路（Djikstra） 路径最大点权和<br>1004 DFS 统计树每层叶子节点个数<br>1005 签到题（格式）</p></blockquote><h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h2><h3 id="1001-A-B-Format-20分"><a href="#1001-A-B-Format-20分" class="headerlink" title="1001 A+B Format (20分)"></a>1001 A+B Format (20分)</h3><pre><code>Calculate a+b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6 ≤ a, b ≤ 10^6. The numbers are separated by a space.Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.Sample Input:-1000000 9Sample Output:-999,991</code></pre><p>这种题还用写么</p><p>需要注意的地方就是输出格式了</p><p>不过这种标准格式可以直接使用Java自带的Format库</p><p>AC代码：</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import java.text.NumberFormat;import java.util.Scanner;public class PAT1001 {    public static void main(String[] args) {        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        int a = scanner.nextInt();        int b = scanner.nextInt();        int sum = a + b;        NumberFormat format = NumberFormat.getInstance();        String result = format.format(sum);        System.out.println(result);    }}</code></pre><h3 id="1002-A-B-for-Polynomials-25分"><a href="#1002-A-B-for-Polynomials-25分" class="headerlink" title="1002 A+B for Polynomials (25分)"></a>1002 A+B for Polynomials (25分)</h3><pre><code>This time, you are supposed to find A+B where A and B are two polynomials.InputEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.OutputFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output3 2 1.5 1 2.9 0 3.2</code></pre><p>这题被坑了一会</p><p>因为答案输出要求始终精确到1位小数</p><p>即像<code>1</code>或者<code>0</code>都要输出成<code>1.0</code>和<code>0.0</code>这样</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import java.text.DecimalFormat;import java.util.Scanner;public class PAT1002 {    public static void main(String[] args) {        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        double[] pol = new double[1001];        for (int i = 0; i &lt; 2; i++) {            int k = scanner.nextInt();            for (int j = 0; j &lt; k; j++) {                int n = scanner.nextInt();                double a = scanner.nextDouble();                pol[n] += a;            }        }        DecimalFormat format = new DecimalFormat("0.0");        int count = 0;        StringBuilder result = new StringBuilder();        for (int i = pol.length - 1; i &gt;= 0; i--) {            if (pol[i] == 0) {                continue;            }            count++;            result.append(" ").append(i).append(" ").append(format.format(pol[i]));        }        result.insert(0, count);        System.out.println(result.toString());    }}</code></pre><h3 id="1003-Emergency-25分"><a href="#1003-Emergency-25分" class="headerlink" title="1003 Emergency (25分)"></a>1003 Emergency (25分)</h3><pre><code>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.InputEach input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) – the number of cities (and the cities are numbered from 0 to N-1), M – the number of roads, C1 and C2 – the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.OutputFor each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.Sample Input5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1Sample Output2 4</code></pre><p>总算来了一道不是签到题的题目</p><p>很容易看出来这是一个节点和边都带权的无向图</p><p>使用<code>狄杰斯特拉（Djikstra）</code>来求解最短路<br>话说每次用到这个算法就想到我同学用的狄杰特斯拉[手动狗头]</p><p>需要分别保存<br>road_count[i] 到达节点i当前共有多少条相同边权的路<br>people[i] 到达节点i后可聚集的最大救援队人数<br>dis[i] 到达节点i的最短路长度<br>pre[i] 访问节点i的前置节点（从哪个节点到的节点i）<br>vis[i] 节点i是否被访问过  </p><p>这题使用邻接矩阵存储了图结构  </p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Scanner;public class PAT1003 {    public static void main(String[] args) {        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        int N = scanner.nextInt();        int M = scanner.nextInt();        int start = scanner.nextInt();        int end = scanner.nextInt();        int[] vertex_team = new int[N];        for (int i = 0; i &lt; N; i++) {            vertex_team[i] = scanner.nextInt();        }        int[][] map = new int[N][N];        for (int i = 0; i &lt; N; i++) {            Arrays.fill(map[i], Integer.MAX_VALUE);        }        for (int i = 0; i &lt; M; i++) {            int from = scanner.nextInt();            int to = scanner.nextInt();            int dis = scanner.nextInt();            map[from][to] = map[to][from] = dis;        }        int[] road_count = new int[N];        road_count[start] = 1;        int[] people = new int[N];        people[start] = vertex_team[start];        int[] dis = new int[N];        Arrays.fill(dis, Integer.MAX_VALUE);        dis[start] = 0;        int[] pre = new int[N];        Arrays.fill(pre, -1);        pre[start] = start;        boolean[] vis = new boolean[N];        for (int i = 0; i &lt; N; i++) {            int now = -1, min = Integer.MAX_VALUE;            for (int j = 0; j &lt; N; j++) {                if (!vis[j] &amp;&amp; dis[j] &lt; min) {                    now = j;                    min = dis[j];                }            }            if (now == -1) {                break;            }            vis[now] = true;            for (int j = 0; j &lt; N; j++) {                if (!vis[j] &amp;&amp; map[now][j] != Integer.MAX_VALUE) {                    if (dis[now] + map[now][j] &lt; dis[j]) {                        dis[j] = dis[now] + map[now][j];                        pre[j] = pre[now];                        people[j] = people[now] + vertex_team[j];                        road_count[j] = road_count[now];                    } else if (dis[now] + map[now][j] == dis[j]) {                        road_count[j] += road_count[now];                        if (people[now] + vertex_team[j] &gt; people[j]) {                            people[j] = people[now] + vertex_team[j];                        }                    }                }            }        }        System.out.printf("%d %d", road_count[end], people[end]);    }}</code></pre><h3 id="1004-Counting-Leaves-30分"><a href="#1004-Counting-Leaves-30分" class="headerlink" title="1004 Counting Leaves (30分)"></a>1004 Counting Leaves (30分)</h3><pre><code>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.InputEach input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:ID K ID[1] ID[2] … ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.OutputFor each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.Sample Input2 101 1 02Sample Output0 1</code></pre><p>这题是树的遍历  </p><p>看题意很容易想到层次遍历，却发现根据输入不太好构建这棵树</p><p>一开始是想这样做的：边读取边建立这一棵二叉树，然后层序遍历。发现题目里没有给明节点给出的顺序，也就无法合理的建树，建森林再连接的话只会增加此题难度。</p><p>于是改变思路：深搜一下这棵树</p><p>利用ArrayList[]保存所有输入结果，一开始还被题目的two-digit number给误导了，其实直接照int读入就行，读取全部输入之后对应的ArrayList[i]就代表了一个节点，如果其中没有孩子，就记录为一个叶子节点，对答案做一次更新即可。</p><p>其实题目给的count的取值只会是1和2，因为非叶子节点至多两个孩子，还可以据此优化。</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Scanner;public class PAT1004 {    static ArrayList&lt;Integer&gt;[] tree = new ArrayList[128];    static int[] ans = new int[128];    static int max_depth = -1;    static void dfs(int index, int depth) {        if (tree[index].size() == 0) {            ans[depth]++;            max_depth = Math.max(max_depth, depth);        }        for (int child : tree[index]) {            dfs(child, depth + 1);        }    }    public static void main(String[] args) {        for (int i = 0; i &lt; tree.length; i++) {            tree[i] = new ArrayList&lt;&gt;();        }        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        int N = scanner.nextInt();        if (N == 0) {            System.out.println(N);            System.exit(0);        }        int M = scanner.nextInt();        for (int i = 0; i &lt; M; i++) {            int root = scanner.nextInt();            int count = scanner.nextInt();            for (int j = 0; j &lt; count; j++) {                int child = scanner.nextInt();                tree[root].add(child);            }        }        dfs(1, 0);        System.out.print(ans[0]);        for (int i = 1; i &lt;= max_depth; i++) {            System.out.print(" " + ans[i]);        }    }}</code></pre><h3 id="1005-Spell-It-Right-20分"><a href="#1005-Spell-It-Right-20分" class="headerlink" title="1005 Spell It Right (20分)"></a>1005 Spell It Right (20分)</h3><pre><code>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.Input Specification:Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10^100).Output Specification:For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.Sample Input:12345Sample Output:one five</code></pre><p>肉眼可见的签到题，一开始看到10的100次方，手打出BigInteger之后看了看题又删掉了。</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Scanner;public class PAT1005 {    public static void main(String[] args) {        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        String input = scanner.nextLine();        int sum = 0;        int len = input.length();        for (int i = 0; i &lt; len; i++) {            sum += input.charAt(i) - '0';        }        String[] words = {"zero", "one", "two", "three", "four",                "five", "six", "seven", "eight", "nine"};        String output = Integer.toString(sum);        len = output.length();        System.out.print(words[output.charAt(0) - '0']);        for (int i = 1; i &lt; len; i++) {            System.out.print(" " + words[output.charAt(i) - '0']);        }    }}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>每天刷题频率不固定 故此系列博客也有咕咕咕的可能</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>五彩斑斓的黑</title>
      <link href="/2020/02/05/wu-cai-ban-lan-de-hei/"/>
      <url>/2020/02/05/wu-cai-ban-lan-de-hei/</url>
      
        <content type="html"><![CDATA[<h1 id="五彩斑斓的黑"><a href="#五彩斑斓的黑" class="headerlink" title="五彩斑斓的黑"></a>五彩斑斓的黑</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>由于众所周知的原因（<code>武汉2020</code>），只能在家整东西玩，想起了以前和同学聊天提到的<code>五彩斑斓的黑</code>，遂来了灵感，造出来这么一个轮子。</p><h2 id="项目效果图"><a href="#项目效果图" class="headerlink" title="项目效果图"></a>项目效果图</h2><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231311731-1891686149.jpg" alt=""></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>五彩斑斓的黑，可以把黑白的论文变成五彩斑斓，这样看论文的时候就不无聊了（误  </p><p>实现了pdf转化为<code>五颜六色</code>的pdf，其实对于其他类型图片的处理也是一样的  </p><h2 id="项目开源地址"><a href="#项目开源地址" class="headerlink" title="项目开源地址"></a>项目开源地址</h2><p><a href="https://github.com/Licsber/Colorful-Black" target="_blank" rel="noopener">我的github</a>，求路过的朋友点个star吧，提PR那是更好的！</p><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><ol><li>必备：opencv 图像处理的基础库</li><li>必备：wand 是imagemagick的前端</li><li>必备：imagemagick 基础库</li><li>选配：flask 用于搭建一个服务器在线批量转换</li></ol><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="读取pdf"><a href="#读取pdf" class="headerlink" title="读取pdf"></a>读取pdf</h3><p>借助wand可以实现pdf转换为jpg图片形式，这样方便使用opencv处理：</p><pre><code>def parse_pdf(filepath, resolution=300):    pdf = wi(filename=filepath, resolution=resolution)    pdf = pdf.convert("jpeg")    return pdf</code></pre><p>转换完毕的pdf批量保存为文件，因为没有找到wand与opencv的联通格式，所以采用文件作保存处理。</p><pre><code>def save_pdf_as_img(pdf, filename):    page_count = 1    for img in pdf.sequence:        page = wi(image=img)        page.save(filename=filename + str(page_count) + '.jpg')        page_count += 1    return page_count</code></pre><h3 id="生成彩色图像"><a href="#生成彩色图像" class="headerlink" title="生成彩色图像"></a>生成彩色图像</h3><p>这里偷了个懒，利用等差数列乘以一个等比数列，采用opencv的热力图applyColorMap()方法变为彩色，再横竖相加获取随机但仍有一定规律的彩虹图像。</p><pre><code>@memoizedef get_color_img(width, height):    w = np.logspace(0, 255, height, base=1.01, dtype=np.uint8)    w = np.reshape(w, (-1, 1))    h = np.linspace(0, 255, width, dtype=np.uint8)    h = np.reshape(h, (1, -1))    shu = w * h    shu = np.reshape(shu, (height, -1))    shu = cv2.cvtColor(shu, cv2.COLOR_GRAY2BGR)    shu = cv2.applyColorMap(shu, cv2.COLORMAP_HSV)    w = np.linspace(0, 255, height, dtype=np.uint8)    w = np.reshape(w, (-1, 1))    h = np.logspace(0, 255, width, base=1.01, dtype=np.uint8)    h = np.reshape(h, (1, -1))    heng = w * h    heng = np.reshape(heng, (height, -1))    heng = cv2.cvtColor(heng, cv2.COLOR_GRAY2BGR)    heng = cv2.applyColorMap(heng, cv2.COLORMAP_HSV)    img = heng + shu    img = cv2.medianBlur(img, 101)    return img</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231452791-1512719541.png" alt=""></p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231546800-1100642836.png" alt=""></p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231709897-2035612081.png" alt=""></p><p>可以看出，使用权重比较大的中值滤波很好的平滑了图像。</p><p>因为替换模版的不变性，所以我们利用python的装饰器在内存中保存这个图像，具体可能我会写一篇关于python高级特性：装饰器的文章，不过还是有可能咕咕咕了，这里就把装饰器理解为一个参数是函数的函数就好了。</p><pre><code>def memoize(func):    cache = dict()    def memoized_func(*args):        if args in cache:            return cache[args]        result = func(*args)        cache[args] = result        return result    return memoized_func</code></pre><h3 id="图像的混合"><a href="#图像的混合" class="headerlink" title="图像的混合"></a>图像的混合</h3><p>利用<code>蒙版（mask）</code>技术，可以完美的实现黑色文字的替换，或者可以自行更改这个要替换的颜色，或者颜色范围，以实现更花里胡哨的效果。</p><pre><code>def mix_img(file_dir, filename, count):    path = os.path.join(file_dir, filename)    for i in range(1, count):        img = cv2.imread(path + str(i) + '.jpg')        color = get_color_img(img.shape[1], img.shape[0])        mask = (img == (0, 0, 0))[:, :, 0]        img[mask] = color[mask]        mix = img        cv2.imwrite(path + str(i) + '.jpg', mix)</code></pre><h3 id="pdf的生成"><a href="#pdf的生成" class="headerlink" title="pdf的生成"></a>pdf的生成</h3><p>混合完的图像还是利用wand复原为pdf文件，生成的pdf可能会比较大，因为变成了纯图像。</p><pre><code>def save_img_as_pdf(file_dir, filename, count, output_dir, output_filename):    path = os.path.join(file_dir, filename)    output_path = os.path.join(output_dir, output_filename)    with wi() as w:        for i in range(1, count):            with wi(filename=path + str(i) + '.jpg') as page:                w.sequence.append(page)        w.save(filename=output_path)    return output_path</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231754432-607854337.jpg" alt=""></p><h3 id="网络端接受上传"><a href="#网络端接受上传" class="headerlink" title="网络端接受上传"></a>网络端接受上传</h3><p>首先让我们5秒写个网页来接受用户pdf文件的输入：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;五彩斑斓的黑 - Licsber&lt;/title&gt;    &lt;link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css"&gt;    &lt;script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;    &lt;script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body class="container"&gt;&lt;div class="jumbotron"&gt;    &lt;h3 id="header"&gt;{{message}}&lt;/h3&gt;    &lt;h2&gt;欢迎试用一键五彩斑斓的黑，支持上传pdf。&lt;/h2&gt;    &lt;h2&gt;创意By Licsber、Mikewang000000。&lt;/h2&gt;    &lt;form id="form1" method="post" action="/api/upload" enctype="multipart/form-data"&gt;        &lt;div&gt;            &lt;input id="File1" type="file" name="myfile" class="btn btn-default btn-lg"&gt;            &lt;button type="submit" class="btn btn-info btn-lg"&gt;提交&lt;/button&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    var heading = $("#header")[0];    setInterval(function () {        if (heading.style.display == "block") {            heading.style.display = "none";        } else if (heading.style.display == "none") {            heading.style.display = "block";        }    }, 1000);&lt;/script&gt;&lt;/html&gt;</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231818228-1698955601.png" alt=""></p><p>闪烁部分是后来写的，主要网页表单部分真的只写了五秒。</p><p>serve一下主页：</p><pre><code>@app.route('/')def upload_test():    message = ''    return render_template(UPLOAD_HTML, message=message)</code></pre><p>然后写一个flask的函数来接收文件并保存，这个函数，嘿嘿，发现了什么东西没，不管符不符合都先保存再说，方便日志记录。</p><pre><code>@app.route('/api/upload', methods=['POST'], strict_slashes=False)def api_upload():    f = request.files['myfile']    if f:        old_name = f.filename        ext = old_name.rsplit('.', 1)[1]        unix_time = int(time.time())        new_filename = old_name + str(unix_time) + '.' + ext        print(new_filename)        path = os.path.join(file_dir, new_filename)        f.save(path)    else:        message = '你没上传文件哦'        return render_template(UPLOAD_HTML, message=message)    if f and allowed_file(f.filename):        pdf = entity.Pdf(file_dir, new_filename, OUTPUT_PATH)        return downloader(pdf.get_output_filename())    else:        message = '文件类型不支持哦 重新上传试试呢'        return render_template(UPLOAD_HTML, message=message)</code></pre><p>下载文件就简单了，flask自带这个方法。</p><pre><code>@app.route("/download/&lt;path:filename&gt;")def downloader(filename):    dir_path = os.path.join(app.root_path, 'output')    return send_from_directory(dir_path, filename, as_attachment=True)</code></pre><h3 id="足够的抽象"><a href="#足够的抽象" class="headerlink" title="足够的抽象"></a>足够的抽象</h3><p>Java程序员表示，看见什么都想给它抽象成一个类：</p><pre><code>class Pdf:    def __init__(self, file_dir, filename, output_path):        self.file_dir = file_dir        self.filename = filename        self.pdf = pdf.parse_pdf(filepath=os.path.join(file_dir, filename))        self.page_count = 0        self.output_path = output_path    def extract(self, tmp_dir='tmp/'):        return pdf.save_pdf_as_img(pdf=self.pdf, filename=tmp_dir + self.filename)    def convert(self):        if self.page_count == 0:            return        color.mix_img(file_dir='tmp/', filename=self.filename, count=self.page_count)        return    def save(self):        return pdf.save_img_as_pdf(file_dir='tmp/', filename=self.filename,                                   count=self.page_count, output_dir=self.output_path, output_filename=self.filename)    def get_output_filename(self):        self.page_count = self.extract()        self.convert()        self.save()        return self.filename</code></pre><p>本来想随机填充的，发现随机生成的图像虽然随机，但是不好看。</p><h2 id="TODOS"><a href="#TODOS" class="headerlink" title="TODOS"></a>TODOS</h2><ol><li>异步返回处理结果（因为算法有点慢</li><li>使用<code>OSS</code>减轻网络io负担</li><li>更多文件图片格式支持</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>还有什么好玩的想法可以私聊我呀（<br>大家试着可以一起实现一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Image Retargeting - 图像缩略图 图像重定向</title>
      <link href="/2020/02/04/image-retargeting-tu-xiang-suo-lue-tu-tu-xiang-chong-ding-xiang/"/>
      <url>/2020/02/04/image-retargeting-tu-xiang-suo-lue-tu-tu-xiang-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Image-Retargeting"><a href="#Image-Retargeting" class="headerlink" title="Image Retargeting"></a>Image Retargeting</h1><h1 id="图像缩略图、图像重定向"><a href="#图像缩略图、图像重定向" class="headerlink" title="图像缩略图、图像重定向"></a>图像缩略图、图像重定向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要对比DL出现之前的几种上古算法，为了作为DL方法的引子而存在，顺便博客也该更新点新内容上来了，这篇博文就是介绍了我最近在玩什么。</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>传统的方法主要有三种：<code>Resize</code>（<code>拉伸、收缩</code>）、<code>Crop</code>（<code>裁剪</code>）和<code>Seam Carving</code>（<code>接缝裁剪</code>）。</p><p>其中接缝裁剪这个算法挺好玩的，论文参见 <a href="https://perso.crans.org/frenoy/matlab2012/seamcarving.pdf" target="_blank" rel="noopener">Seam Carving</a>，截止本篇博文，被引用次数是1914次，可以说是很经典的文章了。</p><p>该论文实现的效果图：</p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204155108091-1437062119.png" alt=""></p><h2 id="本文用到的python库"><a href="#本文用到的python库" class="headerlink" title="本文用到的python库"></a>本文用到的python库</h2><p>三种算法的对比由<code>python</code>实现，python版本为<code>python3.8</code>，对应下列依赖库版本为<code>conda</code>直接安装，不同版本请注意自己改动部分接口。</p><blockquote><p>opencv 用于图像处理<br>scipy 用于图像卷积<br>notebook 提供环境<br>matplotlib 用于图像显示<br>tqdm 用于进度显示（可不用 主要是因为SC算法太慢了 会让人觉得程序卡了<br>numpy 用于辅助opencv  </p></blockquote><p>具体引用代码如下：</p><pre><code>import cv2import matplotlib.pyplot as pltimport numpy as npfrom scipy.ndimage.filters import convolvefrom tqdm import trange</code></pre><h2 id="图像的读入"><a href="#图像的读入" class="headerlink" title="图像的读入"></a>图像的读入</h2><p>都有opencv了，还用问么？</p><pre><code>img = cv2.imread('test1.jpg')imshow(img)img.shape</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154312895-1561165534.png" alt=""></p><h2 id="图像的显示"><a href="#图像的显示" class="headerlink" title="图像的显示"></a>图像的显示</h2><p>其中imshow()函数是自己定义的，用于显示处理结果和处理过程的中间图像，这样就方便在notebook中查看了，需要注意的是opencv存储图像的格式和PIL不太一样，为bgr，需要转换。</p><pre><code>def imshow(img):    if (len(img.shape) == 2) :        plt.imshow(img)        plt.show()        return    b,g,r = cv2.split(img)     img_rgb = cv2.merge([r,g,b])     plt.imshow(img_rgb)    plt.show()</code></pre><h2 id="方法一：裁剪（Crop）"><a href="#方法一：裁剪（Crop）" class="headerlink" title="方法一：裁剪（Crop）"></a>方法一：裁剪（Crop）</h2><p>裁剪配合numpy的<code>花式索引</code>（别笑，这是正式名称）即可实现，本质上就是对数组的划分。</p><p>假如限定屏幕宽度为900像素（因为一般用在手机、iPad等终端上，所以不限制高度），Resize的结果如下：</p><p>左侧裁剪：</p><pre><code>width = 900height = img.shape[0]crop = img[:height, :width]imshow(crop)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154325322-517638521.png" alt=""></p><p>居中裁剪：</p><pre><code>width = 900height = img.shape[0]crop = img[:height, (img.shape[1] - width) // 2 : (img.shape[1] + width) // 2]imshow(crop)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154332238-644614211.png" alt=""></p><p>可以看出，裁剪方法完全没有考虑图像的细节，简单的裁剪带来内容的严重丢失，优点是速度极快，几乎不消耗资源。</p><h2 id="方法二：缩放（Resize）"><a href="#方法二：缩放（Resize）" class="headerlink" title="方法二：缩放（Resize）"></a>方法二：缩放（Resize）</h2><p>缩放也是使用opencv内置函数实现。</p><p>opencv提供了五种Resize方法：</p><blockquote><p>INTER_NEAREST - 最邻近插值<br>INTER_LINEAR - 双线性插值 默认<br>INTER_AREA - resampling using pixel area relation.<br>INTER_CUBIC - 4x4像素邻域内的双立方插值<br>INTER_LANCZOS4 - 8x8像素邻域内的Lanczos插值  </p></blockquote><pre><code>width = 900height = 600resize = cv2.resize(img, (width,height))imshow(resize)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154341929-2099924201.png" alt=""></p><p>可以看出，缩放方法造成了图像的失真，而且是严重失真，其优点也是速度极快，几乎不消耗资源。</p><h2 id="方法三：接缝裁剪（Seam-Carving）"><a href="#方法三：接缝裁剪（Seam-Carving）" class="headerlink" title="方法三：接缝裁剪（Seam Carving）"></a>方法三：接缝裁剪（Seam Carving）</h2><p>这是本文重点介绍的算法，主要思想是图像总有一些不重要的列，将其删除比删除随机的列或者重新填充要更保留图像的细节部分，同时确保图像整体不严重失真（这里的列不是数组意义上的列，是图像中<code>八联通</code>的一条线，即<code>一条接缝</code>）。</p><h3 id="步骤一：获取图像的能量图："><a href="#步骤一：获取图像的能量图：" class="headerlink" title="步骤一：获取图像的能量图："></a>步骤一：获取图像的能量图：</h3><p>能量图就是图像的边缘啦，相当于图像的细节，这里使用偷懒的卷积实现。</p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154544566-1674857637.png" alt=""></p><p>卷积核是这两个：</p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154611703-1241575009.png" alt=""></p><pre><code>def cal_energy(img):    filter_du = np.array([        [1.0, 2.0, 1.0],        [0.0, 0.0, 0.0],        [-1.0, -2.0, -1.0],    ])    filter_du = np.stack([filter_du] * 3, axis=2)    filter_dv = np.array([        [1.0, 0.0, -1.0],        [2.0, 0.0, -2.0],        [1.0, 0.0, -1.0],    ])    filter_dv = np.stack([filter_dv] * 3, axis=2)    img = img.astype('float32')    convolved = np.absolute(convolve(img, filter_du)) + np.absolute(convolve(img, filter_dv))    energy_map = convolved.sum(axis=2)    return energy_mapenergy_map = cal_energy(img)print(energy_map.shape)imshow(energy_map)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154356860-1750141835.png" alt=""></p><p>卷积核是两个，分别从行和列上进行卷积操作。</p><p>这里是用了偷懒的卷积操作，对图像所有像素点做卷积运算，相当于如下C艹代码：</p><pre><code>Mat compute_score_matrix(Mat energy_matrix){    Mat score_matrix = Mat::zeros(energy_matrix.size(), CV_32F);    score_matrix.row(0) = energy_matrix.row(0);    for (int i = 1; i &lt; score_matrix.rows; i++)    {        for (int j = 0; j &lt; score_matrix.cols; j++)        {            float min_score = 0;            // Handle the edge cases            if (j - 1 &lt; 0)            {                std::vector&lt;float&gt; scores(2);                scores[0] = score_matrix.at&lt;float&gt;(i - 1, j);                scores[1] = score_matrix.at&lt;float&gt;(i - 1, j + 1);                min_score = *std::min_element(std::begin(scores), std::end(scores));            }            else if (j + 1 &gt;= score_matrix.cols)            {                std::vector&lt;float&gt; scores(2);                scores[0] = score_matrix.at&lt;float&gt;(i - 1, j - 1);                scores[1] = score_matrix.at&lt;float&gt;(i - 1, j);                min_score = *std::min_element(std::begin(scores), std::end(scores));            }                else            {                std::vector&lt;float&gt; scores(3);                scores[0] = score_matrix.at&lt;float&gt;(i - 1, j - 1);                scores[1] = score_matrix.at&lt;float&gt;(i - 1, j);                scores[2] = score_matrix.at&lt;float&gt;(i - 1, j + 1);                min_score = *std::min_element(std::begin(scores), std::end(scores));            }            score_matrix.at&lt;float&gt;(i, j) = energy_matrix.at&lt;float&gt;(i, j) + min_score;        }    }    return score_matrix;}</code></pre><p>卷积之后的图像即为愿图像的能量图，代表了图像的细节部分，即更锋利的边缘，该算法认为平坦的部分能量更低，自己实验一下就能明白，一方面有效保留了图像中的细节部分，另一方面可能造成算法错误的删除了图像的重要部分，如雪白平坦的胸部等。</p><h3 id="步骤二：获取图像接缝"><a href="#步骤二：获取图像接缝" class="headerlink" title="步骤二：获取图像接缝"></a>步骤二：获取图像接缝</h3><p>图像的接缝就是一个八联通的线，每行有且只能选取一个像素，这里使用动态规划，回溯法求解，dp转移方程如下：</p><h1 id="M-i-j-e-i-j-min-M-i-1-j-1-M-i-1-j-M-i-1-j-1"><a href="#M-i-j-e-i-j-min-M-i-1-j-1-M-i-1-j-M-i-1-j-1" class="headerlink" title="M(i, j) = e(i, j) + min{M(i - 1, j - 1), M(i - 1, j), M(i - 1, j + 1)}"></a>M(i, j) = e(i, j) + min{M(i - 1, j - 1), M(i - 1, j), M(i - 1, j + 1)}</h1><pre><code>def minimum_seam(img):    r, c, _ = img.shape    energy_map = cal_energy(img)    M = energy_map.copy()    backtrack = np.zeros_like(M, dtype=np.int)    for i in range(1, r):        for j in range(c):            if j == 0:                idx = np.argmin(M[i - 1, j:j + 2])                backtrack[i, j] = idx + j                min_energy = M[i - 1, idx + j]            else:                idx = np.argmin(M[i - 1, j - 1:j + 2])                backtrack[i, j] = idx + j - 1                min_energy = M[i - 1, idx + j - 1]            M[i, j] += min_energy    return M, backtrackM, backtrack = minimum_seam(img)imshow(M)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154411900-1071566696.png" alt=""></p><p>图像的接缝由dp求出，可以看出这个算法是十分慢的，同时因为损失最小的接缝被删掉后，该接缝涉及到的左右两侧的损失不能直接复用，必须重新计算，进一步减慢了算法的执行速度。</p><h3 id="步骤三：裁剪一列"><a href="#步骤三：裁剪一列" class="headerlink" title="步骤三：裁剪一列"></a>步骤三：裁剪一列</h3><p>接缝都求出来了，很明显裁剪的那一列就应该是损失最小的接缝，删除方法使用numpy的黑科技argmin()。</p><pre><code>def carve_column(img):    r, c, _ = img.shape    M, backtrack = minimum_seam(img)    mask = np.ones((r, c), dtype=np.bool)    j = np.argmin(M[-1])    for i in reversed(range(r)):        mask[i, j] = False        j = backtrack[i, j]    mask = np.stack([mask] * 3, axis=2)    img = img[mask].reshape((r, c - 1, 3))    return imgfor i in trange(100):    one = carve_column(img)imshow(one)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154424005-1274066801.png" alt=""></p><p>这里模拟删除图像中100列之后的情况。</p><h3 id="最终步骤：按需裁剪图像"><a href="#最终步骤：按需裁剪图像" class="headerlink" title="最终步骤：按需裁剪图像"></a>最终步骤：按需裁剪图像</h3><p>这里把函数参数改为缩放倍数，其实也可以写为删除列数，都一样，符合人类直觉即可。</p><pre><code>def crop_c(img, scale_c):    r, c, _ = img.shape    new_c = int(scale_c * c)    for i in trange(c - new_c):        img = carve_column(img)    return imgcrop = crop_c(img, 0.8)imshow(crop)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154751467-739890815.png" alt=""></p><p>注意这张图没使用原尺寸进行运算，6小时实在难等。</p><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204210910989-355683456.png" alt=""></p><p>6小时之后更新的图片，缩小了20%。</p><p>可以看到，原图像在被接缝裁剪后，保留了本身的细节，未引入大面积失真，缺点是慢！慢！慢！测试图像是一个4K的图像，运算删除一列需要30s，删除20%的列就是768列，总计用时6小时！这样处理图片的速度估计没人可以接受吧。</p><h3 id="拓展：裁剪图像的行"><a href="#拓展：裁剪图像的行" class="headerlink" title="拓展：裁剪图像的行"></a>拓展：裁剪图像的行</h3><p>很明确了，翻转一下行不就变成列了，复用一下就ok。</p><pre><code>def crop_r(img, scale_r):    img = np.rot90(img, 1, (0, 1))    img = crop_c(img, scale_r)    img = np.rot90(img, 3, (0, 1))    return imgcrop = crop_r(img, 0.8)imshow(crop)</code></pre><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204210755195-881561140.png" alt=""></p><p>图像效果，运行了三个小时。</p><h3 id="拓展：目标移除"><a href="#拓展：目标移除" class="headerlink" title="拓展：目标移除"></a>拓展：目标移除</h3><p><img src="https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200204154728721-2056960417.png" alt=""></p><p>理解了原算法之后这就很容易理解了，将能量图中需要重点保留的东西能量加高，需要删除的东西能量减低，利用蒙版（mask）即可快速实现目标移除的效果，这里直接贴原论文的效果图喽。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>根据保密协定，DL部分代码暂不贴出，我才不会说我还没看懂呢（</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/GeorgeSeif/Image-Processing-OpenCV/blob/master/Seam-Carving/Source.cpp" target="_blank" rel="noopener">Image-Processing-OpenCV</a><br><a href="https://karthikkaranth.me/blog/implementing-seam-carving-with-python/" target="_blank" rel="noopener">Implementing Seam Carving with Python</a><br><a href="https://juejin.im/post/5d8471f66fb9a06aee366b30" target="_blank" rel="noopener">Seam carving–让图片比例随心缩放</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java OJ 快速读入 竞赛用</title>
      <link href="/2020/01/31/java-oj-kuai-su-du-ru-jing-sai-yong/"/>
      <url>/2020/01/31/java-oj-kuai-su-du-ru-jing-sai-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Java打比赛太吃亏了吧<br>人家C艹有超快的getchar()<br>最不济cin的效率也比Java带的Scanner高<br>还有内存占用方面<br>竞赛中都不计算Java的内存占用<br>因为占用太多了（  在空间上卡Java一卡一个准  </p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><img src="https://img2018.cnblogs.com/blog/1007765/202001/1007765-20200131132901780-1410040085.png" alt=""></p><h2 id="利用读入二维数组进行测试："><a href="#利用读入二维数组进行测试：" class="headerlink" title="利用读入二维数组进行测试："></a>利用读入二维数组进行测试：</h2><h2 id="用StreamTokenizer是最快的方法"><a href="#用StreamTokenizer是最快的方法" class="headerlink" title="用StreamTokenizer是最快的方法"></a>用StreamTokenizer是最快的方法</h2><p>代码如下：  </p><pre><code>public class TokenRead {    public static int[][] bufferedRead() throws IOException {        StreamTokenizer scanner = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));        scanner.nextToken();        long initTime = System.currentTimeMillis();        int n = (int) scanner.nval;        int[][] all = new int[n][];        for (int i = 0; i &lt; n; i++) {            scanner.nextToken();            int count = (int) scanner.nval;            all[i] = new int[count];            for (int j = 0; j &lt; count; j++) {                scanner.nextToken();                all[i][j] = (int) scanner.nval;            }        }        long nowTime = System.currentTimeMillis();        System.out.println((nowTime - initTime));        return all;    }</code></pre><p>大概是其他读入方法的数量级的差距</p><p>对比算法1:   </p><pre><code>    public static int[][] bufferedRead(String input) {        Scanner scanner = new Scanner(new BufferedInputStream(System.in));        scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));        int n = scanner.nextInt();        long initTime = System.currentTimeMillis();        int[][] all = new int[n][];        for (int i = 0; i &lt; n; i++) {            int num = scanner.nextInt();            all[i] = new int[num];            for (int j = 0; j &lt; num; j++) {                int value = scanner.nextInt();                all[i][j] = value;            }        }        long nowTime = System.currentTimeMillis();        System.out.println((nowTime - initTime));        return all;    }</code></pre><p>对比算法2:  </p><pre><code>    public static int[][] lineRead(String input) {        Scanner scanner = new Scanner(new BufferedInputStream(System.in));        int n = scanner.nextInt();        long initTime = System.currentTimeMillis();        scanner.nextLine();        int[][] all = new int[n][];        for (int i = 0; i &lt; n; i++) {            String num = scanner.nextLine();            String[] nums = num.split(" ");            int len = Integer.parseInt(nums[0]);            all[i] = new int[len];            for (int j = 0; j &lt; len; j++) {                all[i][j] = Integer.parseInt(nums[j + 1]);            }        }        long nowTime = System.currentTimeMillis();        System.out.println((nowTime - initTime));        return all;    }</code></pre><p>对比算法3:  </p><pre><code>    public static int[][] forceRead(String input) {        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        long initTime = System.currentTimeMillis();        int[][] all = new int[n][];        for (int i = 0; i &lt; n; i++) {            int num = scanner.nextInt();            all[i] = new int[num];            for (int j = 0; j &lt; num; j++) {                int value = scanner.nextInt();                all[i][j] = value;            }        }        long nowTime = System.currentTimeMillis();        System.out.println((nowTime - initTime));        return all;    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 高级特性介绍 - 迭代的99种姿势 与协程</title>
      <link href="/2020/01/26/python-gao-ji-te-xing-jie-shao-die-dai-de-99-chong-zi-shi-yu-xie-cheng/"/>
      <url>/2020/01/26/python-gao-ji-te-xing-jie-shao-die-dai-de-99-chong-zi-shi-yu-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-高级特性介绍-迭代的99种姿势-与协程"><a href="#Python-高级特性介绍-迭代的99种姿势-与协程" class="headerlink" title="Python 高级特性介绍 - 迭代的99种姿势 与协程"></a>Python 高级特性介绍 - 迭代的99种姿势 与协程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="https://img2018.cnblogs.com/blog/1007765/202001/1007765-20200127060727218-1029141039.png" alt=""></p><blockquote><p>写这个笔记记录一下一点点收获<br>测试环境版本：  </p><ol><li>Python 3.7.4 (default, Sep 28 2019, 16:39:19)<br>Python2老早就停止支持了 所以还是跟进py3吧 </li><li>macOS Catalina 10.15.1</li></ol></blockquote><h2 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h2><blockquote><p>Python中一样可以使用for进行迭代<br>与C、Java等一众语言有区别的是<br>python中迭代更像是Java的<code>逐元循环（foreach）</code>  </p></blockquote><h3 id="Java用法（下标迭代）："><a href="#Java用法（下标迭代）：" class="headerlink" title="Java用法（下标迭代）："></a>Java用法（下标迭代）：</h3><pre><code>for (int i = 0; i &lt; array.length; ++i) {    operation(array[i]);}</code></pre><blockquote><p>可以看到 对于存在下标的Java数组而言<br>利用数组下标进行遍历更加符合直觉（数组就是一块<code>连续的内存空间</code> 加上 <code>下标</code>作为偏移量）<br>Java内部实现：数组变量int[] array作为数据存储在Java的<code>栈</code>里<br>而数组本身在<code>堆</code>中创建 其<code>引用</code>被赋值给array  </p></blockquote><h3 id="等价的python代码："><a href="#等价的python代码：" class="headerlink" title="等价的python代码："></a>等价的python代码：</h3><pre><code>for i in range(len(list)):    operation(list[i])</code></pre><blockquote><p>问题来了 如果也想使用相似的下标方式该怎么办呢<br>python自带了<code>enumerate</code>函数可以帮助我们实现：  </p></blockquote><h3 id="等价的python代码：-1"><a href="#等价的python代码：-1" class="headerlink" title="等价的python代码："></a>等价的python代码：</h3><pre><code>for i, value in enumerate(list):    operation(value)</code></pre><blockquote><p>其实python自带的<code>dict</code>本身实现了这个操作：</p></blockquote><h3 id="python同时对key和value进行迭代"><a href="#python同时对key和value进行迭代" class="headerlink" title="python同时对key和value进行迭代"></a>python同时对key和value进行迭代</h3><pre><code>for key, value in dict.items():    operation(key, value)</code></pre><blockquote><p>下面就是抽象程度更高的循环了：<br>其不光可以用在带<code>下标</code>的数据类型上<br>对于<code>可迭代（Iterable）</code>的所有元素都可以这样操作  </p></blockquote><h3 id="Java用法（逐元循环）："><a href="#Java用法（逐元循环）：" class="headerlink" title="Java用法（逐元循环）："></a>Java用法（逐元循环）：</h3><pre><code>int[] array = new int[len];for(int i : array) {    // 注意这里是深拷贝     // 如果对i做赋值等操作无意义    operation(i);}</code></pre><h3 id="等价的python用法："><a href="#等价的python用法：" class="headerlink" title="等价的python用法："></a>等价的python用法：</h3><pre><code>for i in list:    operation(i)</code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>在python中 有时候会遇到创建容量很大的list的需求<br>假如list中每个元素都可以利用算法推出来  如：  </p></blockquote><pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><blockquote><p>就可以利用<code>列表生成式（List Comprehensions）</code>来实现：  </p></blockquote><pre><code>a = [x for x in range(10)]</code></pre><blockquote><p>假如想生成<code>1e10</code>个元素呢？<br>一方面会遇到内存容量不足的情况<br>还有如果我们访问过前几个元素便不需要这个list了<br>就会造成极大的内存浪费  </p></blockquote><blockquote><p>这里从案例引入<code>生成器</code>的概念<br>有时候小白在学习python<br>很容易把列表的创建符号打错<br>如下  </p></blockquote><pre><code>a = {1, 2, 1}</code></pre><blockquote><p>学过c和Java的程序员以为这样会创建一个数组<br>但是在python里这是一个set（集合）<br>其特点是无序且不重复<br>于是上面的等价代码如下：  </p></blockquote><pre><code>a = {1, 2}</code></pre><blockquote><p>和直觉（Java程序员的）相违背</p></blockquote><blockquote><p>还有同学写成了这样的形式：</p></blockquote><pre><code>a = (1, 2)</code></pre><blockquote><p>这样就创建了一个tuple（元组）<br>其特点是元素不可修改  </p></blockquote><blockquote><p>最后一种小白写成了这样：  </p></blockquote><pre><code>a = (x for x in range(10))</code></pre><blockquote><p>乍一看和上面列表生成式很像<br>用它迭代试试呢：  </p></blockquote><pre><code>for i in range(len(a)):    print(i)</code></pre><blockquote><p>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: object of type ‘generator’ has no len()  </module></stdin></p></blockquote><blockquote><p>嗯哼？出现了意料之外的结果<br>所以我们到底创建了一个什么呢？<br>用<code>type()</code>看一看：  </p></blockquote><blockquote><p>&lt;class ‘generator’&gt;</p></blockquote><blockquote><p>哦豁 这是个啥 <code>generator(生成器)</code>？<br>查一下资料 好像这个就是我们需要的<br>这个东西就可以解决上面提到的问题<br>不必占用大量内存 还可以满足迭代需求  </p></blockquote><h3 id="对生成器的迭代方式："><a href="#对生成器的迭代方式：" class="headerlink" title="对生成器的迭代方式："></a>对生成器的迭代方式：</h3><pre><code>next(generator)</code></pre><blockquote><p>如果迭代完成 会获得<code>StopIteration</code>的异常<br>当然这样很不优雅<br>要知道生成器也是<code>可迭代(Iterable)</code>的：</p></blockquote><pre><code>for i in generator:    operation(i)</code></pre><blockquote><p>这样就可以愉快的迭代了  </p></blockquote><blockquote><p>等会 如果想生成一个无法用列表生成式表达的list呢？<br>比如 斐波那契数列<br>这样很容易利用函数写出 却无法使用一层for直接给出的  </p></blockquote><pre><code>def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        print(b)        a, b = b, a + b        n = n + 1    return 'done'</code></pre><blockquote><p>这个函数可以输出fib的前n个数<br>那么怎么得到这样的生成器呢？<br>很简单 只需要把输出语句改为yield即可：  </p></blockquote><pre><code>def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        yield b        a, b = b, a + b        n = n + 1    return 'done'</code></pre><blockquote><p>yield在其中的作用相当于return<br>其英文意思本身就是<code>产出</code>嘛<br>但是是在每次调用next时return<br>下一次从yield处重新开始计算<br>这样就可以方便的迭代斐波那契数列了：</p></blockquote><pre><code>for i in fib(100):    print(i)</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代器(Iterator)和可迭代(Iterable)<br>python内置的集合数据类型都是可迭代的<br>如<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>、<code>str</code>等<br><code>生成器</code>也是<code>可迭代</code>的<br>总而言之 可以作用于for循环的对象都是可迭代的  </p></blockquote><blockquote><p>但是迭代器是另一个概念<br>代表可以被next()函数调用的对象<br>其一定是惰性计算的<br>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是可迭代但不是迭代器<br>不过可以通过iter()函数获得一个迭代器对象<br>迭代器通常表示一个数据流 并且可以是无限大的  </p></blockquote><blockquote><p>在Java中 对<code>集合（Collections）</code>的遍历操作可以通过迭代器进行<br>迭代器的基本方法有<code>hasNext()</code>、<code>next()</code>、<code>remove()</code><br>它支持以不同的方式遍历一个聚合对象<br>同时还有<code>ListIterator</code>扩展<code>Iterator接口</code>来实现列表的双向遍历和元素的修改<br>这一点也和设计模式中迭代器模式很相似  </p></blockquote><p>其优点有：</p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>需要为聚合对象提供多种遍历方式</li><li>为遍历不同的聚合结构提供一个统一的接口  </li></ol><blockquote><p>其实Java的编译器会自动把标准的foreach循环自动转换为Iterator遍历<br>因为Iterator对象是集合对象自己在内部创建的<br>它自己知道如何<code>高效遍历内部</code>的数据集合  </p></blockquote><h2 id="python的协程"><a href="#python的协程" class="headerlink" title="python的协程"></a>python的协程</h2><blockquote><p>你以为这篇笔记到此为止了吗？<br>天真 其实才<code>刚刚开始</code><br>这篇写作的动机在于  </p></blockquote><h2 id="go的协程和python的协程"><a href="#go的协程和python的协程" class="headerlink" title="go的协程和python的协程"></a><code>go的协程和python的协程</code></h2><p>首先复习一下  </p><blockquote><p>进程、线程和协程的基本概念<br>进程：操作系统<code>资源分配</code>的最小单位<br>线程：操作系统<code>资源调度</code>的最小单位<br>协程：<code>语言层面</code>实现的对线程的调度  </p></blockquote><blockquote><p>程序：指令、数据及其组织形式的描述<br>进程：程序的实体<br>多线程：在单个程序中同时运行多个线程完成不同的工作  </p></blockquote><p>go的<code>设计哲学</code>最重要的就有一个：  </p><blockquote><p>不要使用共享内存来通信 要使用通信来共享内存  </p></blockquote><blockquote><p>现在都讲究高并发<br>挺重要的一点就是异步操作<br>比如io操作通常需要是异步的<br>这一点在前端的一些语言中体现的比较多<br>比如<code>setTimeout()</code><br>比如微信小程序开发中<br>会用到<code>promise回调</code><br>微信中常见的用到异步回调接口  </p></blockquote><pre><code>wx.function({  success: () =&gt; console.log('success'),  fail: () =&gt; console.log('failure'),})</code></pre><blockquote><p>这样很不优雅<br>因为一旦逻辑多了 小白很容易写成回调地狱形式<br>解决方案是可以封装成promise回调<br>这里直接贴一道面试题吧<br>调用<code>async</code>修饰的方法会直接返回一个<code>Promise</code>对象  </p></blockquote><pre><code>async function async1(){    console.log('async1 start')    await async2()    console.log('async1 end')}async function async2(){    console.log('async2')}console.log('script start')setTimeout(function(){    console.log('setTimeout')},0)  async1();new Promise(function(resolve){    console.log('promise1')    resolve();}).then(function(){    console.log('promise2')})console.log('script end')</code></pre><blockquote><p>实测的输出：</p></blockquote><pre><code>[Log] script start[Log] async1 start[Log] async2[Log] promise1[Log] script end[Log] promise2[Log] async1 end&lt; undefined[Log] setTimeout</code></pre><blockquote><p>如果更追求优雅的话 封成proxy都可以<br>这里略过不表  </p></blockquote><blockquote><p>python就借鉴了前端<code>async</code>和<code>await</code>的模式<br>（其实这才是<code>异步的终极解决方案</code>么<br>内置实现是<code>asyncio</code>库  </p></blockquote><blockquote><p>import一下 看看内部有什么实现<br>dir(asyncio)<br>[‘ALL_COMPLETED’, ‘AbstractChildWatcher’, ‘AbstractEventLoop’, ‘AbstractEventLoopPolicy’, ‘AbstractServer’, ‘BaseEventLoop’, ‘BaseProtocol’, ‘BaseTransport’, ‘BoundedSemaphore’, ‘BufferedProtocol’, ‘CancelledError’, ‘Condition’, ‘DatagramProtocol’, ‘DatagramTransport’, ‘DefaultEventLoopPolicy’, ‘Event’, ‘FIRST_COMPLETED’, ‘FIRST_EXCEPTION’, ‘FastChildWatcher’, ‘Future’, ‘Handle’, ‘IncompleteReadError’, ‘InvalidStateError’, ‘LifoQueue’, ‘LimitOverrunError’, ‘Lock’, ‘PriorityQueue’, ‘Protocol’, ‘Queue’, ‘QueueEmpty’, ‘QueueFull’, ‘ReadTransport’, ‘SafeChildWatcher’, ‘SelectorEventLoop’, ‘Semaphore’, ‘SendfileNotAvailableError’, ‘StreamReader’, ‘StreamReaderProtocol’, ‘StreamWriter’, ‘SubprocessProtocol’, ‘SubprocessTransport’, ‘Task’, ‘TimeoutError’, ‘TimerHandle’, ‘Transport’, ‘WriteTransport’, ‘<strong>all</strong>‘, ‘<strong>builtins</strong>‘, ‘<strong>cached</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>file</strong>‘, ‘<strong>loader</strong>‘, ‘<strong>name</strong>‘, ‘<strong>package</strong>‘, ‘<strong>path</strong>‘, ‘<strong>spec</strong>‘, ‘_all_tasks_compat’, ‘_enter_task’, ‘_get_running_loop’, ‘_leave_task’, ‘_register_task’, ‘_set_running_loop’, ‘_unregister_task’, ‘all_tasks’, ‘as_completed’, ‘base_events’, ‘base_futures’, ‘base_subprocess’, ‘base_tasks’, ‘constants’, ‘coroutine’, ‘coroutines’, ‘create_subprocess_exec’, ‘create_subprocess_shell’, ‘create_task’, ‘current_task’, ‘ensure_future’, ‘events’, ‘format_helpers’, ‘futures’, ‘gather’, ‘get_child_watcher’, ‘get_event_loop’, ‘get_event_loop_policy’, ‘get_running_loop’, ‘iscoroutine’, ‘iscoroutinefunction’, ‘isfuture’, ‘locks’, ‘log’, ‘new_event_loop’, ‘open_connection’, ‘open_unix_connection’, ‘protocols’, ‘queues’, ‘run’, ‘run_coroutine_threadsafe’, ‘runners’, ‘selector_events’, ‘set_child_watcher’, ‘set_event_loop’, ‘set_event_loop_policy’, ‘shield’, ‘sleep’, ‘sslproto’, ‘start_server’, ‘start_unix_server’, ‘streams’, ‘subprocess’, ‘sys’, ‘tasks’, ‘transports’, ‘unix_events’, ‘wait’, ‘wait_for’, ‘wrap_future’]</p></blockquote><blockquote><p>可以看到 内部方法还是挺多的  </p></blockquote><p>介绍如下：<br>asyncio 提供一组<code>高层级</code>API 用于:  </p><ol><li><code>并发</code>地运行Python 协程并对其执行过程实现完全控制  </li><li>执行<code>网络IO</code>和<code>IPC</code>  </li><li>控制<code>子进程</code>  </li><li>通过<code>队列</code>实现<code>分布式</code>任务  </li><li><code>同步</code>并发代码  </li></ol><blockquote><p>在这个库出现之前怎么写异步呢？<br>前面介绍了<code>生成器</code>和<code>yield</code><br>但是少介绍了一个函数<br>和<code>next()</code>配套使用的<code>send()</code><br><code>next()</code>完全等价于<code>send(None)</code><br><code>子程序</code>就是<code>协程</code>的一种特例</p></blockquote><blockquote><p>这里引用廖雪峰的一个生产者消费者模型：</p></blockquote><pre><code>def consumer():    r = ''    while True:        n = yield r        if not n:            return        print('[CONSUMER] Consuming %s...' % n)        r = '200 OK'def produce(c):    c.send(None)    n = 0    while n &lt; 5:        n = n + 1        print('[PRODUCER] Producing %s...' % n)        r = c.send(n)        print('[PRODUCER] Consumer return: %s' % r)    c.close()c = consumer()produce(c)</code></pre><blockquote><p>可以看到整个流程<code>无锁</code><br>由一个<code>线程</code>执行<br>produce和consumer<code>协作</code>完成任务<br>所以称为<code>“协程”</code><br>而非线程的抢占式多任务  </p></blockquote><blockquote><p>这样写很不优雅<br>但是在asyncio出现之前的协程只有这一种写法<br>出现之后：</p></blockquote><pre><code>import asyncio@asyncio.coroutinedef hello():    print("Hello world!")    # 异步调用asyncio.sleep(1):    r = yield from asyncio.sleep(1)    print("Hello again!")# 获取EventLoop:loop = asyncio.get_event_loop()# 执行coroutineloop.run_until_complete(hello())loop.close()</code></pre><blockquote><p>熟悉前端编程的同学应该看出来了<br><code>@asyncio.coroutine</code>这不就是<code>async</code><br><code>yield from</code>这不就是<code>await</code>么  </p></blockquote><blockquote><p>有个小坑就是<br>原生的生成器不能直接用于await操作<br>需要用async修饰之后<br>生成器变成了异步生成器<br>这样就可以作用于await操作了  </p></blockquote><blockquote><p>这一点go和erlang等语言做的就很好<br>python因为是后来才支持的协程<br>所以如果一个方法是async的<br>连带着调用的所有方法都需要是async的  </p></blockquote><blockquote><p>python内部实现是<code>eventloop模型</code><br>go和erlang的实现是<code>CSP(Communicating Sequential Processes)</code><br>这里略过不表  </p></blockquote><pre><code>import asyncio# @asyncio.coroutineasync def hello():    print('hello')    # r = yield from asyncio.sleep(5)    r = await asyncio.sleep(5)    print('hello again '.format(r))# @asyncio.coroutineasync def wget(host):    print('wget host:{}'.format(host))    conn = asyncio.open_connection(host, 80)    # reader, writer = yield from conn    reader, writer = await conn    header = 'GET / HTTP/1.0\r\nHost: {}\r\n\r\n'.format(host)    writer.write(header.encode('utf-8'))    # yield from writer.drain()    await writer.drain()    while True:        # line = yield from reader.readline()        line = await reader.readline()        if line == b'\r\n':            break        print('{} header: {}'.format(host, line.decode('utf-8').rstrip()))    writer.close()if __name__ == '__main__':    loop = asyncio.get_event_loop()    tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]    loop.run_until_complete(asyncio.wait(tasks))    loop.close()</code></pre><blockquote><p>这一点在后端编程上用的比较多<br>补充知识点就是各种io模型<br>比如BIO、NIO、AIO等<br>一般Java面试会碰到吧  </p></blockquote><blockquote><p>而go的协程作为其最大的特性之一<br>一开始就占据了先机<br>内部实现是用的<code>goroutine</code>和<code>channel</code><br>通信机制非常简单<br>传数据用<code>channel &lt;- data</code><br>取数据用<code>&lt;-channel</code>  </p></blockquote><blockquote><p>go的<code>MPG</code>模型：<br><code>M</code>即<code>Machine</code> 一个<code>M</code>直接关联一个<code>内核线程</code><br><code>P</code>即<code>Processor</code> 代表<code>M</code>需要的<code>上下文</code>环境 也是处理<code>用户级代码逻辑</code>的处理器<br><code>G</code>即<code>Goroutine</code> 本质上也是一种轻量级的<code>线程</code></p></blockquote><blockquote><p>go采用的这种模型 从语言层面支持了并发<br>其实现挺像Java的线程池的 但是轻轻松松创建百万个goroutine<br>Java线程创几万个就会占用很高的内存了（大概1个1MB左右）  </p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>廖雪峰的python教程<br>谷歌来的各种资料<br>后面应该会再写一个关于装饰器的文章吧<br>大概（咕咕咕</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记MacOs视频mov与mp4格式转换问题解决</title>
      <link href="/2019/12/20/ji-macos-shi-pin-mov-yu-mp4-ge-shi-zhuan-huan-wen-ti-jie-jue/"/>
      <url>/2019/12/20/ji-macos-shi-pin-mov-yu-mp4-ge-shi-zhuan-huan-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><ol><li>记录了<code>mov</code>转<code>mp4</code>格式的方法  </li><li>记录了自己是多蠢</li></ol><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>这学期选修的《工程英语视听说》课，需要提交一段口语考试视频，于是乎：<br>带着我的大疆Mavic Mini 和iPad Pro出去，一顿操作之后，有了视频和录音文件<br>回到实验室用Final Cut Pro剪了一下 原片3G多 压成720p刚好满足提交的300M要求<br>但是你以为这样就完了吗？ 学校的这鬼系统告诉你：没这么简单 他有格式要求！  </p><hr><blockquote><p>期末考试口语视频录制任务<br>【本项为期末考试口语测试部分，占期末考试总分20%】<br>内容要求：<br>观看短视频，就视频内容“机器人是否会取代人类所有工作”发表自己观点，录制成视频文件提交至云班课本项作业。<br>录制及提交要求：  </p><ol><li>正对镜头，录制1-2分钟视频，存为MP4格式。<br>录制视频或视频格式转换时，请选择正确的视频编码格式和音频编码格式。<br>视频编码格式应该选择AVC（常被称为H.264），音频编码格式应该选择AAC。<br>视频文件大小不要超过300M，可以通过调整视频尺寸（480×360、320×240等）来控制文件大小。  </li><li>将视频文件以附件形式提交至云班课本项作业。  </li><li>将视频文本内容输入至云班课作业文字内容区域。<br>千万勿以Word文档或拍照图片附件形式提交。如评分为零，责任自负。  </li></ol><p>提交截止日期：2019年12月24日23:59<br>（过时不补，该项成绩为零）  </p><p>【特别提醒】</p><ol><li>如发现内容雷同，无论谁抄袭谁，一律计为零分。  </li><li>如举报抄袭雷同，经查属实，举报者该项成绩上浮10%  </li></ol></blockquote><hr><h1 id="问题尝试"><a href="#问题尝试" class="headerlink" title="问题尝试"></a>问题尝试</h1><ol><li><p>方案一<br>起初看了一眼，这不就是<code>mp4</code>的文艺说法么，直接打开VLC，一键转换<code>Convert</code>！<br>然而。。 这个软件“云班课“他并不认识VLC转出来的<code>m4v</code>文件<br>在传到手机上 改拓展名等试了半天之后（主要是因为网速<br>发现确实没法识别  </p></li><li><p>方案二<br>编码格式有问题，这不简单么，打开<code>ffmpeg</code>，等下，我<code>ffmpeg</code>呢？<br>上次重装<code>brew</code>好像被删了！ 那不怂：<br> brew install ffmpeg<br>之后就是 又因为网速原因 坐等了半个小时！<br><img src="https://img2018.cnblogs.com/blog/1007765/201912/1007765-20191220224930679-5247008.png" alt=""></p></li></ol><ol start="3"><li>方案三（找基友）<br>期间跟基友交流了一下 让他直接转码给我<br>因此时视频文件已经传到了QQ中转站<br>然而，基友那边码率没调好，用的ffmpga默认的码率<br>第一遍2分钟转了一个极其AV画质的视频<br><img src="https://img2018.cnblogs.com/blog/1007765/201912/1007765-20191220225007799-915780122.png" alt=""></li></ol><p>开玩笑好吗 我录制的时候是<code>2.7K@60FPS</code><br>于是乎，又坐等了一会看知乎<br>总算找到了解决方案！如下：  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p><a href="https://www.zhihu.com/question/19552889" target="_blank" rel="noopener">Mac 上有 .mov 转 MP4 的免费软件吗？ - 知乎</a>  </p></blockquote><p>没错，只需要简单的把 <code>QuickTime Player</code> 导出的 <code>mov</code> 格式文件重命名为 <code>mp4</code> 即可<br>没错，只需要简单的把 <code>QuickTime Player</code> 导出的 <code>mov</code> 格式文件重命名为 <code>mp4</code> 即可<br>没错，只需要简单的把 <code>QuickTime Player</code> 导出的 <code>mov</code> 格式文件重命名为 <code>mp4</code> 即可<br>折腾了大概两小时。吐血。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记 2019蓝桥杯校内预选赛(JAVA组) 赛后总结</title>
      <link href="/2019/11/20/ji-2019-lan-qiao-bei-xiao-nei-yu-xuan-sai-java-zu-sai-hou-zong-jie/"/>
      <url>/2019/11/20/ji-2019-lan-qiao-bei-xiao-nei-yu-xuan-sai-java-zu-sai-hou-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>好像博客好久没更新了 哈哈哈哈哈<br>趁现在有空更新一波<br>不知道还有没有人看<br>确实该记录一下每天做了什么了<br>不然感觉有些浑浑噩噩了  </p><h1 id="比赛介绍"><a href="#比赛介绍" class="headerlink" title="比赛介绍"></a>比赛介绍</h1><p>全称: 蓝桥杯全国软件和信息技术专业人才大赛<br>蓝桥杯 实话 省赛就是花钱拿奖<br>去年啥都不懂 刚进大学还是个大一小萌新<br>C还没用熟就混了个省二回来<br>确实感受到了比赛比较水<br>不愧是暴力杯<br>不过因为学校比较low的原因<br>没有组织ACM等比赛<br>所以蓝桥是我们能参加的可以说比较高的赛事了吧<br>毕竟一流的二本 二流的一本名不虚传 hhhh<br>今年准备再打一下试试<br>看看能不能进国赛<br>说实话 大一以来做这么多硬件的东西<br>对算法这一块还真的没做多少  </p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="1-计算机存储中-15-125GB是多少MB"><a href="#1-计算机存储中-15-125GB是多少MB" class="headerlink" title="1. 计算机存储中 15.125GB是多少MB"></a>1. 计算机存储中 15.125GB是多少MB</h3><blockquote><p>这题好像根本没挖坑<br>如果挖坑可以把大写的B(Byte字节)改成小写的b(bit比特)<br>估计跳进去的人才会有吧<br>没啥好说的  </p><blockquote><p>题解: 15.125 * 1024<br>打开计算器敲一下就有了</p></blockquote></blockquote><h3 id="2-两个二进制数11110011101和1111101001的和是多少？请用二进制表示"><a href="#2-两个二进制数11110011101和1111101001的和是多少？请用二进制表示" class="headerlink" title="2. 两个二进制数11110011101和1111101001的和是多少？请用二进制表示"></a>2. 两个二进制数11110011101和1111101001的和是多少？请用二进制表示</h3><blockquote><p>没啥好说的<br>打开计算器<br>点开程序员模式-二进制<br>手敲一遍即得到答案  </p><blockquote><p>题解: 自己算去吧</p></blockquote></blockquote><h3 id="3-在2019个有区别的球中选3个球放在一个盘子里，请问有多少种选法？"><a href="#3-在2019个有区别的球中选3个球放在一个盘子里，请问有多少种选法？" class="headerlink" title="3. 在2019个有区别的球中选3个球放在一个盘子里，请问有多少种选法？"></a>3. 在2019个有区别的球中选3个球放在一个盘子里，请问有多少种选法？</h3><blockquote><p>蓝桥杯果然是高中生刚来大学来虐大学生的<br>哈哈哈哈哈<br>组合数公式不用问了吧<br>好多你们的学长学姐都忘了  </p><blockquote><p>题解: C(2019, 3)</p></blockquote></blockquote><h3 id="4-一个包含有2019个结点的无向连通图，最少包含多少条边？"><a href="#4-一个包含有2019个结点的无向连通图，最少包含多少条边？" class="headerlink" title="4. 一个包含有2019个结点的无向连通图，最少包含多少条边？"></a>4. 一个包含有2019个结点的无向连通图，最少包含多少条边？</h3><blockquote><p>自己想一下<br>当然是一条链最少了<br>此时这个图退化成一个树了  </p><blockquote><p>题解: n - 1 = 2018  </p></blockquote></blockquote><h2 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a>程序题</h2><h3 id="5-递增三元组"><a href="#5-递增三元组" class="headerlink" title="5. 递增三元组"></a>5. 递增三元组</h3><blockquote><p>问题描述<br>  在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>  给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>输入格式<br>  输入的第一行包含一个整数 n。<br>  第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>输出格式<br>  输出一行包含一个整数，表示答案。<br>样例输入<br>5<br>1 2 5 3 5<br>样例输出<br>2<br>样例说明<br>  a[2] 和 a[4] 可能是三元组的中心。<br>评测用例规模与约定<br>  对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>  对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。  </p></blockquote><blockquote><p>很容易理解的是<br>一个数 只要左边有比它小的<br>右边有比它大的 即符合<br>所以暴力解法就是直接暴力 没啥好说的<br>dp解法: 维护两个数组<br>分别是最长上升子序列的长度<br>和最长下降子序列的长度(倒序搜索)<br>转移方程: dp[i] = max(dp[i], dp[j] + 1)</p><blockquote><p>题解: 代码略</p></blockquote></blockquote><h3 id="6-逆序对"><a href="#6-逆序对" class="headerlink" title="6. 逆序对"></a>6. 逆序对</h3><blockquote><p>问题描述<br>  在数列 a_1, a_2, …, a_n中，如果 a_i 和 a_j 满足 i &lt; j 且 a_i &gt; a_j，则称为一个逆序数对。<br>  给定一个数列，请问数列中总共有多少个逆序数对。<br>输入格式<br>  输入的第一行包含一个整数 n。<br>  第二行包含 n 个整数 a_1, a_2, …, a_n，相邻的整数间用空格分隔，表示给定的数列。<br>输出格式<br>  输出一行包含一个整数，表示答案。<br>样例输入<br>6<br>3 1 5 2 3 5<br>样例输出<br>4<br>评测用例规模与约定<br>  对于 50% 的评测用例，1 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>  对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。  </p></blockquote><blockquote><p>这题比较有意思<br>据学长说是字节跳动的一面题 hhhh<br>学长说写暴力的直接滚蛋<br>一般可以想到归并排序<br>不过能想到树状数组的估计也很少了吧<br>哪天专门写一篇介绍树状数组 (二叉索引树)<br>用暴力这题绝对超时 (比如菜鸡的我)  </p><blockquote><p>题解: 1. 归并排序<br>边归并边统计逆序数对的数量<br>统计完整个数组也有序了 挺方便的方法<br>题解: 2. 树状数组<br>学长居然说<br>“树状数组我校估计不超过十五个人听说过”<br>“（虽然现在高中竞赛生册那已经开始学树链剖分了”<br>(贴学长原话不会被打吧 hhhh)</p></blockquote></blockquote><h3 id="7-反倍数"><a href="#7-反倍数" class="headerlink" title="7. 反倍数"></a>7. 反倍数</h3><blockquote><p>问题描述<br>  给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。<br>  请问在 1 至 n 中有多少个反倍数。<br>输入格式<br>  输入的第一行包含一个整数 n。<br>  第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。<br>输出格式<br>  输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>2 3 6<br>样例输出<br>10<br>样例说明<br>  以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。<br>评测用例规模与约定<br>  对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br>  对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>  对于所有评测用例，1 &lt;= n &lt;= 1000000，1 &lt;= a &lt;= n，1 &lt;= b &lt;= n，1 &lt;= c &lt;= n。  </p></blockquote><blockquote><p>这题没啥好说的 就是写个check函数 然后把值扔进去<br>不过我做了个超简单的dp(其实总觉得dp就是空间换时间)<br>筛了一些数 刚开始想了gcd 好像没什么特殊发现就没写上去  </p><blockquote><p>题解: 确定入门题还需要题解?</p></blockquote></blockquote><h3 id="8-前序距离"><a href="#8-前序距离" class="headerlink" title="8. 前序距离"></a>8. 前序距离</h3><blockquote><p>问题描述<br>  给定一个序列 a_1, a_2, …, a_n。其中 a_1 是最大的数，没有其他数与 a_1 相等。<br>  对于从第二个数开始的每个数 a_i，请找到位置在 a_i 之前且比 a_i 大的，位置上距离 a_i 最近的数 a_j。称 i-j 为 a_i 的前向距离。<br>  对于给定的序列，请求出所有数的前向距离之和。<br>输入格式<br>  输入的第一行包含一个整数 n，表示序列的长度。<br>  第二行包含 n 个正整数，为给定的序列。<br>输出格式<br>  输出一个整数，表示序列中所有数的前向距离之和。<br>样例输入<br>8<br>9 1 3 5 2 7 6 3<br>样例输出<br>14<br>样例说明<br>  序列中从第二项开始的前向距离依次为：<br>  1, 2, 3, 1, 5, 1, 1<br>  和为14。<br>数据规模和约定<br>  对于70%的评测用例，1 &lt;= n &lt;= 1000；<br>  对于所有评测用例，1 &lt;= n &lt;= 100000，a_1 &lt;= 1000000。<br>  请注意答案可能很大，可能需要使用 long long 来保存。  </p></blockquote><blockquote><p>答案可能很大 emm 还是用了long 总觉得Java打这种一般用不上大整数类<br>除非一些题明确写了高精度计算 不过这样的题一般我也做不出来 太菜了<br>这题也需要优化 暴力肯定超时<br>学长说像“合唱队形”<br>还是需要维护一个跳转表<br>避免n!(话说阶乘复杂度的代码真的能跑完吗)的匹配情况<br>感觉这样的匹配表很像kmp 但是更像并查集<br>虽然还没手撕过并查集   </p><blockquote><p>题解: 1. 并查集<br>一个数组prev表示前一个比当前数大的索引<br>然后后面的数比到这个数的时候如果相等就不用一路比回去了<br>极端情况下还是会超时 比如已知升序且无重复<br>[9999999, 1, 2, …, 9999998]<br>优化一下:<br>···<br>prev[j]表示j之前离j最近比a[j]大的索引<br>那么a[j]肯定比从prev[j] + 1 到j - 1都大<br>所以当a[i] &gt; a[j]时 [j, i - 1]范围内的元素都比a[i]小<br>[prev[j], j - 1]范围内的元素都比a[j]小<br>所以也一定比a[i]小<br>所以从prev[j]到j - 1可以直接跳<br>j直接跳到prev[j]即可接着查<br>···  </p></blockquote></blockquote><h3 id="9-V型坐标"><a href="#9-V型坐标" class="headerlink" title="9. V型坐标"></a>9. V型坐标</h3><blockquote><p>问题描述<br>  当夜深人静时，小明喜欢独自凝望着天空。<br>  这一天，小明看着满天的繁星，突发奇思妙想，他发现可以通过用直线连接天空中的星星来组成美丽的图案。<br>  小明想到一个非常简单的图案：大写的V，如果连接三颗星星，中间一颗最靠下方，这样的形状就是一个大V了。<br>  小明越想越着迷，他想知道，天空中最亮的 n 颗星星，可以有多少种方式组成大V。<br>  为了更严谨的看待问题，小明把自己所见范围的天空映射到了一个平面直角坐标系中，他看到的最亮的 n 颗星星在这个坐标系中都有自己的坐标。<br>  如果三颗星星的坐标分别为 (x_i, y_i), (x_j, y_j), (x_k, y_k)，当 x_i &lt; x_j &lt; x_k 且 y_j &lt; y_i 且 y_j &lt; y_k 时，这三颗星星就组成了一个大 V。<br>输入格式<br>  输入的第一行包含一个整数 n 。<br>  接下来 n 行，每行两个整数，每一行表示一颗星星的 x 坐标和 y 坐标。<br>输出格式<br>  输出一行包含一个整数，表示有多少种方式组成大V。<br>样例输入<br>5<br>4 5<br>2 3<br>1 4<br>3 3<br>5 8<br>样例输出<br>4<br>评测用例规模与约定<br>  对于 30% 的评测用例，2 &lt;= n &lt;= 50，星星的坐标为不超过 1000 的非负整数。<br>  对于 50% 的评测用例，2 &lt;= n &lt;= 100，星星的坐标为不超过 1000 的非负整数。<br>  对于 80% 的评测用例，2 &lt;= n &lt;= 1000，星星的坐标为不超过 10000 的非负整数。<br>  对于所有评测用例，2 &lt;= n &lt;= 5000，星星的坐标为不超过 100000 的非负整数。  </p></blockquote><blockquote><p>小明脑子不太对系列<br>可以去知乎回答问题了<br>这题没啥好讲的<br>写个check函数 然后就了事了<br>一开始忘了排序 傻傻的连样例都没过 还愣了我半分钟<br>这题排序是对x排序 顺带改变y 别排错了<br>不过还是要注意时间<br>感觉和第五题差不多 也是<br>维护两个数组<br>分别是最长上升子序列的长度<br>和最长下降子序列的长度(倒序搜索)  </p><blockquote><p>题解: 略 和第五题一样</p></blockquote></blockquote><h3 id="10-选节目"><a href="#10-选节目" class="headerlink" title="10. 选节目"></a>10. 选节目</h3><blockquote><p>问题描述<br>  小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。<br>  这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。<br>  小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。<br>  小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。<br>输入格式<br>  输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。<br>  第二行包含 n 个整数，依次为每个节目的好看值。<br>输出格式<br>  输出一行包含 m 个整数，为选出的节目的好看值。<br>样例输入<br>5 3<br>3 1 2 5 4<br>样例输出<br>3 5 4<br>样例说明<br>  选择了第1, 4, 5个节目。<br>评测用例规模与约定<br>  对于 30% 的评测用例，1 &lt;= n &lt;= 20；<br>  对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>  对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。  </p></blockquote><blockquote><p>这题. 不知道是出题人的问题还是我的问题<br>没看懂想要干什么<br>于是乎直接写了排序之后输出最大的m个(按原来次序)<br>出来问了学长 学长跟我写的一样 .. 看来都没看懂出题人想干啥  </p><blockquote><p>题解: 就排个序 没了 注意边界处理  </p></blockquote></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为校赛什么都不计入 加上还有点事情要处理<br>所以看了看题 写了点东西 明白自己还有哪点不会就溜了<br>去年模拟我好像是全校倒数第一吧 hhhh 菜的真实<br>这次发现平时看一些题还是有用的<br>比如树状数组 虽然该用上的时候自己一时半会也撕不出来 (<br>归并排序 并查集 各种dp<br>总之 加油!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记利用frp配合nginx实现内网透传</title>
      <link href="/2019/02/02/ji-li-yong-frp-pei-he-nginx-shi-xian-nei-wang-tou-chuan/"/>
      <url>/2019/02/02/ji-li-yong-frp-pei-he-nginx-shi-xian-nei-wang-tou-chuan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp下载</a>  </p><h1 id="背景"><a href="#背景" class="headerlink" title="背景 :"></a>背景 :</h1><p>内网有一台服务器A 在NAT背后  </p><p>无法被其他客户端访问  </p><p>借助公网服务器B来配置内网透传  </p><p>即可通过B来访问A  </p><h1 id="服务端安装frps-启动-frps-c-frps-ini"><a href="#服务端安装frps-启动-frps-c-frps-ini" class="headerlink" title="服务端安装frps 启动: ./frps -c frps.ini"></a>服务端安装frps <code>启动: ./frps -c frps.ini</code></h1><h2 id="配置文件frps-ini如下"><a href="#配置文件frps-ini如下" class="headerlink" title="配置文件frps.ini如下"></a>配置文件<code>frps.ini</code>如下</h2><pre><code>[common]subdomain_host = example.com # 为父域名    bind_port = 1234 # 为frp使用的端口vhost_http_port = 8080 # 为外网服务器的端口token = XXX # frp客户端和服务端token相同才可连接</code></pre><h1 id="客户端安装frpc-启动-frpc-c-frpc-ini"><a href="#客户端安装frpc-启动-frpc-c-frpc-ini" class="headerlink" title="客户端安装frpc 启动: ./frpc -c frpc.ini"></a>客户端安装frpc <code>启动: ./frpc -c frpc.ini</code></h1><h2 id="配置文件frps-ini如下-1"><a href="#配置文件frps-ini如下-1" class="headerlink" title="配置文件frps.ini如下"></a>配置文件<code>frps.ini</code>如下</h2><pre><code>[common]server_addr = example.com # 为服务器地址server_port = 1234 # frp端口token = XXX # frp客户端和服务端token相同才可连接[web] # 开启web转发服务type = http # 方式: httplocal_port = 88 # 本地服务的端口subdomain = sub # 子域名locations = / # 根</code></pre><h1 id="配置nginx的转发规则"><a href="#配置nginx的转发规则" class="headerlink" title="配置nginx的转发规则"></a>配置nginx的转发规则</h1><h2 id="配置nginxsudo-vim-etc-nginx-nginx-conf如下"><a href="#配置nginxsudo-vim-etc-nginx-nginx-conf如下" class="headerlink" title="配置nginxsudo vim /etc/nginx/nginx.conf如下"></a>配置nginx<code>sudo vim /etc/nginx/nginx.conf</code>如下</h2><pre><code>    underscores_in_headers on;    server{        listen 80;        listen [::]:80;        server_name sub.example.com; # 这里设置子域名转发规则        location / {            #underscores_in_headers on;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://localhost:8080;  # 这里是vhost_http_port         }    }</code></pre><p>这样就实现了访问 <code>sub.example.com</code>  </p><p>转发到本地的<code>localhost:88</code>  </p><p>这里需要注意的是 nginx对http header中包含下划线的header信息都会过滤掉  </p><p>所以需要添加 <code>underscores_in_headers on;</code>   才能转发自定义的header信息</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记macbook pro装Android studio 并下载sdk</title>
      <link href="/2018/10/26/ji-macbook-pro-zhuang-android-studio-bing-xia-zai-sdk/"/>
      <url>/2018/10/26/ji-macbook-pro-zhuang-android-studio-bing-xia-zai-sdk/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/1007765/201810/1007765-20181026194538502-1540448250.png" alt="accept"></p><p><img src="https://img2018.cnblogs.com/blog/1007765/201810/1007765-20181026194707301-617956037.png" alt="sdk列表"></p><p>mirrors.dormforce.net<img src="https://img2018.cnblogs.com/blog/1007765/201810/1007765-20181026195134704-580790474.png" alt=""></p><p>203.208.39.226 dl.google.com</p><p>Write access is allowed from event dispatch thread only</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[科普]记远程协助女生修电脑????</title>
      <link href="/2018/10/23/ke-pu-ji-yuan-cheng-xie-zhu-nu-sheng-xiu-dian-nao/"/>
      <url>/2018/10/23/ke-pu-ji-yuan-cheng-xie-zhu-nu-sheng-xiu-dian-nao/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-故事背景"><a href="#0x00-故事背景" class="headerlink" title="0x00 故事背景"></a>0x00 故事背景</h2><p>某年某月某日， win10的自动更新又又又又抽风了：<br><img src="https://img2018.cnblogs.com/blog/1007765/201810/1007765-20181023204520081-7820972.jpg" alt="图示"><br>于是 尽管我强调了N遍 我是学电脑的 不是修电脑的<br>还是被找上了门….</p><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>- 电脑的五大件(有时候也称四大件)  </p><ul><li><p>主板 CPU 内存 硬盘 (显卡)<br>- 其中 你的<em>电脑系统</em>是装在<em>硬盘</em>上的  </p></li><li><p>(原因: 硬盘容量大 价格便宜 内存速度快 容量小 但是断电数据就消失)  </p></li><li><p>(系统装内存上的大佬请不要看这篇面向小白的科普文)<br><br>- 硬盘就像是房子 里面住着各种住户  </p></li><li><p>比如你的<em>系统<em>和</em>用户数据</em><br></p></li><li><p>系统的启动是从<em>BIOS(Basic Input &amp; Output System</em>开始的<br>- 所有的启动引导都是写在硬盘的一开始的一点点空间的<br>- (因为电脑在最基础的系统中 寻址只能找到硬盘的最前面一点)  </p></li><li><p>所以这一块区域被称作<em>MBR(主引导记录)</em>  </p></li><li><p>(要是介绍UEFI GRUB 这文就不叫科普文了 给小白看的文章 大佬见谅)  </p></li><li><p>(顺便安利一下知乎的老狼 他写的文章生动形象 易于理解)  </p></li><li><p>主板BIOS的默认设置就是从自己的硬盘引导系统  </p></li><li><p>而引导的说明(MBR)记录了系统(如win10)在硬盘里的位置  </p></li><li><p>如果是一次正常的启动  </p></li><li><p>那么过程就到此为止了  进入windows系统  输入密码  </p></li><li><p>这就是小白眼中的电脑了  </p></li></ul><h2 id="0x02-But"><a href="#0x02-But" class="headerlink" title="0x02 But"></a>0x02 But</h2><p>然而事情总会不遂人愿<br>哪天你忘记了电脑的密码 这该怎么办呢?<br>小白第一时间想到了重装系统<br>这当然是一种可行的解决方案<br>可是 常规的重装会清除C盘的数据<br>而小白总会求助于黑电脑店<br>(特指那种”恢复”桌面文件还另收费的黑心商人)<br>这该咋办呢? <br></p><h2 id="0x03-配置PE"><a href="#0x03-配置PE" class="headerlink" title="0x03 配置PE"></a>0x03 配置PE</h2><ol><li>准备一个空U盘 找一个室友的电脑  </li><li>在网上(老毛桃或者大白菜PE) 这俩已经很经典了<br>2.1 下载到自己的电脑上  而不是U盘里</li><li>打开 顺着安装教程安装进U盘</li><li>重启你的电脑 开机狂按 F10 或F11 或F12<br>4.1 具体百度一下 “自己的电脑型号+如何进BIOS或如何选择引导</li><li>选择从U盘启动 进入PE后选择登陆密码清除</li></ol><h2 id="0x04-解释"><a href="#0x04-解释" class="headerlink" title="0x04 解释"></a>0x04 解释</h2><p>具体解释:  </p><ol><li>只要硬盘没加密 系统加密都是笑话</li><li>加密文件(SAM文件)放在Windows目录里</li><li>只要能把它删掉 或者替换一个空白的进去 就能去掉用户账户</li><li>如果你有微软账户 请直接用它重置密码 这种方法没有必要</li><li>一般启动的时候 BIOS都会从硬盘引导</li><li>而硬盘上就是有密码的系统 </li><li>而选择了从U盘启动之后 硬盘是作为外接设备存在的</li><li>可以理解为 此时的U盘是硬盘 而你的硬盘才是U盘 插在这个PE系统上</li><li>所以可以轻而易举的删掉那个记录着用户密码的文件</li></ol><h2 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h2><p>小白请教的时候请把每一步都问清楚<br>而我们学电脑的…. 也得学会解释<br>需要记着 在我们这的默认值 惯常值<br>在小白那里 很可能完全不一样</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言写的2048小游戏</title>
      <link href="/2018/10/17/c-yu-yan-xie-de-2048-xiao-you-xi/"/>
      <url>/2018/10/17/c-yu-yan-xie-de-2048-xiao-you-xi/</url>
      
        <content type="html"><![CDATA[<p>基于”基于C_语言的2048算法设计_颜冠鹏.pdf”<br>这一篇文献提供的思路<br>在中国知网上能找到 就不贴具体内容了<br>[摘 要] 针对2048的游戏规则，分析了该游戏的算法特点，对其相关的功能需求和算法设计进行了简单介绍，提出了一种 新的设计方案。解决了该设计在方阵数据结构、运动算法和游戏结束判断方面的问题，并阐述了以队列方式进行坐标运算和操 作扩展的关键技术。软件测试表明，该设计的方块数值最大值受方阵阶数和操作次数的限制，四阶方阵的理论最大值为 65 536， 智力极高的人可达 16 384，而一般人仅能达到 2 048 左右。<br>[关键词] 2048 算法设计 数据结构 坐标运算 队列<br>中图分类号:TP301.6 文献标识码:A 文章编号:1008- 1739(2014)24- 62- 5</p><p>主要是几个小的函数<br>用两个for循环打印地图和遍历地图<br>把一个4*4的二维数组改成一个一维数组来简化处理思路</p><p>##学到的知识<br>switch函数每一个case都需要加break来结束判断<br>for在c99标准下 初始化的循环变量和外界所有变量毫无关系<br>c99标准才有了布尔型变量<br>尽量不要大循环套小循环 嵌套四层循环之后就晕了 下断点都不好调试<br>如果数组越界访问会返回0<br>随机数函数必须撒种子 不然每次都是同一个值</p><pre><code>////  main.c//  2048//  表示 为了练习C语言 在这先写着一个小游戏吧//  “听说以后上课要用？”//  调试代码已注释 目前游戏所有功能均实现//  唯一不足的是在苹果系统环境无getch函数//  且不会自行实现 在其他系统直接include &lt;conio.h&gt;//  把getchar改为getch即可畅玩2048//  Created by licsber on 2018/10/11.//  Copyright © 2018 licsber. All rights reserved.//#include &lt;stdio.h&gt;//emmmm#include &lt;stdbool.h&gt; //c里没有布尔型变量 c99标准才加的#include &lt;time.h&gt;//用于产生随机数#include &lt;stdlib.h&gt;//#include &lt;ncurses.h&gt;//图形界面库 等后来更新printMap函数再引用void gameStart(void);//游戏开始void randomAdd(void);//在空格随机加2和4 其中2为十分之九概率void printMap(void);//用printf打印地图void getDirection(void);//读取键盘输入void moveUp(void);//上void moveDown(void);//下void moveLeft(void);//左void moveRight(void);//右void moveForward(void);//推进void moveMerge(void);//合并bool checkIfGameOver(void);//检测游戏是否over 即无空位同时相邻数组元素各不相等void restart(void);//重新开始void loop(void);//循环游戏//int countZero(void);//还有几个是0//int returnZero(int line);int score = 0;//当前得分int map[4][4]={    {0,0,0,0},    {0,0,0,0},    {0,0,0,0},    {0,0,0,0}};//这是地图 用二维数组实现int tmp[4] = {0,0,0,0};void gameStart(void){    printf("Welcome to play 2048 game! by licsber\n");    randomAdd();    printMap();    printf("[w][s][a][d]move [r]restart [q]quit\n");}void randomAdd(void){    srand((unsigned int)time(NULL));//撒随机数种子    //printf("%d",rand());    int i,j,time = 0;//行 列 循环次数(debug用)    do{        i = rand() % 4;        j = rand() % 4;        time++;    }while (map[i][j] != 0);    if (rand() % 10 == 0 ) {        map[i][j]=4;    }    else{        map[i][j]=2;    }    //printf("%d",time);    //上面的代码在格子快满之后也有几率循环N次都不停    //todo改进方案：先找到所有空格子    //下面的代码是有问题的 有几率无限循环    /*     bool finish = 0;//本轮是否已放置方块     for (int i = 0; i &lt; 4; i++) {     for (int j = 0; j &lt; 4; j++) {     if (!map[i][j]) {     if (rand() % 16 == 0 &amp;&amp; finish == 0) {     // 十分之一的概率放4     if (rand() % 10 == 0 ) {     map[i][j]=4;     }     else{     map[i][j]=2;     }     finish = 1;     }     }     }     }     if (finish == 0) {     randomAdd();     }     else{     return;     }     */}void printMap(void){    for (int i = 0; i &lt; 4; i++) {        printf("          ");        for (int j = 0; j &lt; 4; j++) {            printf("%4d ",map[i][j]);        }        printf("\n");    }    return;}void getDirection(void){    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;    char in = getchar();    switch (in) {        case 'w':            moveUp();            break;        case 's':            moveDown();            break;        case 'a':            moveLeft();            break;        case 'd':            moveRight();            break;        case 'r':            restart();            break;        case 'q':            exit(0);            break;        default:            getDirection();            break;    }}void moveUp(void){    for (int line = 0; line &lt; 4; line++) {        for (int i = 0; i &lt; 4; i++) {            tmp[i] = map[i][line];        }        moveMerge();        for (int i = 0; i &lt; 4; i++) {            map[i][line] = tmp[i];        }    }}void moveDown(void){    for (int line = 0; line &lt; 4; line++) {        for (int i = 0; i &lt; 4; i++) {            tmp[3 - i] = map[i][line];        }        moveMerge();        for (int i = 0; i &lt; 4; i++) {            map[i][line] = tmp[3 - i];        }    }}void moveLeft(void){    for (int line = 0; line &lt; 4; line++) {        for (int i = 0; i &lt; 4; i++) {            tmp[i] = map[line][i];        }        moveMerge();        for (int i = 0; i &lt; 4; i++) {            map[line][i] = tmp[i];        }    }}void moveRight(void){    for (int line = 0; line &lt; 4; line++) {        for (int i = 3; i &gt;= 0; i--) {            tmp[3 - i] = map[line][i];        }        moveMerge();        for (int i = 3; i &gt;= 0; i--) {            map[line][i] = tmp[3 - i];        }    }}bool checkIfGameOver(void){    //先检查格子是不是都满了    for (int i = 0; i &lt; 4; i++) {        for (int j = 0; j &lt; 4; j++) {            if (!map[i][j]) {                //只要有空的格子 游戏就没结束                return false;            }        }    }    //格子满了之后    for (int i = 0; i &lt; 4; i++) {        for (int j = 0; j &lt; 3; j++) {            if (map[i][j] == map[i+1][j] || map[i][j] == map[i][j+1]) {                //如果一个格子和它右边或下边相等 游戏也没结束                //这里数组如果越界访问会返回0 所以不影响结果                return false;            }        }    }    return true;}void moveForward(void){    //i为0的话就把最先一个非零的j挪到i的位置    int j = 0;    for (int i = 0; i &lt; 4; i++) {        j++;        if (tmp[i] == 0) {            for (; j &lt; 4; j++) {                if (tmp[j] != 0) {                    tmp[i] = tmp[j];                    tmp[j] = 0;                    break;                }            }        }    }}void moveMerge(void){    //处理合并 每合并一次就推进一次    moveForward();    for (int i = 0; i &lt; 3; i++) {        if (tmp[i] == tmp[i + 1]) {            tmp[i] *=2;            tmp[i + 1] = 0;            moveForward();        }    }}/*int countZero(void){    int zero = 0;    for (int i = 0; i &lt; 4; i++) {        for (int j = 0; j &lt; 4; j++) {            if (!map[i][j]) {                zero++;            }        }    }    return zero;}*/void restart(void){    for (int i = 0; i &lt; 4; i++) {        for (int j = 0; j &lt; 4; j++) {            map[i][j] = 0;        }    }    gameStart();    loop();}void loop(void){    for(;;) {        getDirection();        printMap();        for (int i = 0; i &lt; 4; i++) {            for (int j = 0; j &lt; 4; j++) {                if (!map[i][j]) {                    //只要有空的格子 就加                    randomAdd();                    goto go;                }            }        }    go:        if (checkIfGameOver() ==  true){            printf("You are lose!");            exit(0);        }    }}int main() {    gameStart();    loop();    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记如何用树莓派3开一个无线AP</title>
      <link href="/2018/10/12/ji-ru-he-yong-shu-mei-pai-3-kai-yi-ge-wu-xian-ap/"/>
      <url>/2018/10/12/ji-ru-he-yong-shu-mei-pai-3-kai-yi-ge-wu-xian-ap/</url>
      
        <content type="html"><![CDATA[<p>###开热点 忘掉自己手动配置吧<br><a href="https://github.com/oblique/create_ap" target="_blank" rel="noopener">create_ap</a></p><pre><code>git clone git@github.com:oblique/create_ap.gitcd create_apsudo make installsudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq</code></pre><pre><code>ifconfig</code></pre><pre><code>docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:f0:71:8e:08  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0enxb827eb07b15a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.2.109  netmask 255.255.255.0  broadcast 192.168.2.255        inet6 fe80::6964:9416:8de7:2826  prefixlen 64  scopeid 0x20&lt;link&gt;        ether b8:27:eb:07:b1:5a  txqueuelen 1000  (Ethernet)        RX packets 328524  bytes 478811996 (456.6 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 163059  bytes 12426695 (11.8 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 592  bytes 66641 (65.0 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 592  bytes 66641 (65.0 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><pre><code>sudo create_ap wlan0 enxb827eb07b15a pi 12345678 --no-virt</code></pre><pre><code>WARN: brmfmac driver doesn't work properly with virtual interfaces and      it can cause kernel panic. For this reason we disallow virtual      interfaces for your adapter.      For more info: https://github.com/oblique/create_ap/issues/203Config dir: /tmp/create_ap.wlan0.conf.pCYxzIAxPID: 1386Sharing Internet using method: nathostapd command-line interface: hostapd_cli -p /tmp/create_ap.wlan0.conf.pCYxzIAx/hostapd_ctrlConfiguration file: /tmp/create_ap.wlan0.conf.pCYxzIAx/hostapd.confFailed to create interface mon.wlan0: -95 (Operation not supported)wlan0: Could not connect to kernel driverUsing interface wlan0 with hwaddr b8:27:eb:52:e4:** and ssid "pi"wlan0: interface state UNINITIALIZED-&gt;ENABLEDwlan0: AP-ENABLED wlan0: STA 00:be:3b:ab:a6:** IEEE 802.11: associatedwlan0: AP-STA-CONNECTED 00:be:3b:ab:a6:**wlan0: STA 00:be:3b:ab:a6:** RADIUS: starting accounting session 5BC05FA2-00000000wlan0: STA 00:be:3b:ab:a6:** WPA: pairwise key handshake completed (WPA)wlan0: STA 00:be:3b:ab:a6:** WPA: group key handshake completed (WPA)wlan0: STA 80:56:f2:80:24:** IEEE 802.11: associatedwlan0: AP-STA-CONNECTED 80:56:f2:80:24:**wlan0: STA 80:56:f2:80:24:** RADIUS: starting accounting session 5BC05FA2-00000001wlan0: STA 80:56:f2:80:24:** WPA: pairwise key handshake completed (WPA)wlan0: STA 80:56:f2:80:24:** WPA: group key handshake completed (WPA)wlan0: STA 80:56:f2:80:24:** WPA: group key handshake completed (WPA)wlan0: STA 00:be:3b:ab:a6:** WPA: group key handshake completed (WPA)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记Macbook Pro配合FT232使用PN532模块</title>
      <link href="/2018/10/11/ji-macbook-pro-pei-he-ft232-shi-yong-pn532-mo-kuai/"/>
      <url>/2018/10/11/ji-macbook-pro-pei-he-ft232-shi-yong-pn532-mo-kuai/</url>
      
        <content type="html"><![CDATA[<p>####0x00实话。 被自己傻到<br>在linux下使用 <code>libusb + libnfc</code> 这两个库就可以配合串口直接使用pn532模块<br>当时配置文件是写在 <code>/etc/nfc</code> 目录下的<br>而我在OS X 下居然也想着这样干。<br>##硬件列表</p><pre><code>绿联的type-c拓展坞一个。FT232 usb转串口模块一个。PN532 nfc通讯模块一个。</code></pre><p>##0x01硬件连接<br>没啥好说的 rxd接模块txd 反之亦然<br>还有。 如果mac没有正确识别串口驱动<br>到<a href="https://www.ftdichip.com/FTDrivers.htm" target="_blank" rel="noopener">ftdi的官网</a>下载即可<br>注意别选错系统版本 mac Mojave的版本号是14 high Sierra是13</p><p>还有一个小注意点是 如何测试usb转uart模块是否配置好<br>把模块的rxd直接接上txd 然后 <code>ls /dev/cu.*</code><br>找到类似于<code>/dev/cu.usbserial-00003214</code>这样的设备<br>然后 <code>screen /dev/cu.usbserial-00003214</code>随便按几下键盘<br>看看是不是在屏幕上有返回 理论上是按什么返回什么</p><p>##0x02库安装<br><a href="https://github.com/nfc-tools/libnfc" target="_blank" rel="noopener">libnfc</a><br><a href="https://github.com/libusb/libusb" target="_blank" rel="noopener">libusb</a><br>自行安装 不在赘述 github界面写的非常清楚</p><p>##0x03nfc-tools<br><a href="https://github.com/nfc-tools/mfoc" target="_blank" rel="noopener">mfoc</a><br><a href="https://github.com/nfc-tools/mfcuk" target="_blank" rel="noopener">mfcuk</a><br>这几个常用的软件怎么用就不介绍了</p><p>##0x04软件调试（重头戏）</p><pre><code>nfc-list uses libnfc 1.7.10 device(s) found</code></pre><p>错误原因是啥呢. 就是我说的 我在<code>/etc/nfc</code>目录下创建配置文件了 </p><pre><code>log_level=3</code></pre><p>这个我记得调了 然而 ….<br>直到我看到了<a href="https://github.com/nfc-tools/libnfc/issues/411" target="_blank" rel="noopener">这个</a><br><code>LIBNFC_LOG_LEVEL=3 nfc-list</code><br>才发现。 一直都没有设置配置文件</p><pre><code>info    libnfc.config    Unable to open file: /opt/local/etc/nfc/libnfc.confdebug    libnfc.config    Unable to open directory: /opt/local/etc/nfc/devices.ddebug    libnfc.general    log_level is set to 3debug    libnfc.general    allow_autoscan is set to truedebug    libnfc.general    allow_intrusive_scan is set to falsedebug    libnfc.general    0 device(s) defined by usernfc-list uses libnfc 1.7.1debug    libnfc.general    0 device(s) found using acr122_usb driverdebug    libnfc.general    0 device(s) found using pn53x_usb driverNo NFC device found.</code></pre><p>##0x05真相大白..<br>mac配置文件应该放在<code>/opt/local/etc</code>里<br>然后就好了..<br>##0x06    Ps.<br>然而配置好之后还是没有什么卵用</p><pre><code>Card is not vulnerable to nested attack</code></pre><p>我的免费洗澡计划又泡汤了.<br>接下来考虑物理攻击<br>比如钕铁硼超强磁铁去搞电磁阀[手动滑稽]</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次MacBook Pro无法连接wifi网络修复</title>
      <link href="/2018/10/06/ji-yi-ci-macbook-pro-wu-fa-lian-jie-wifi-wang-luo-xiu-fu/"/>
      <url>/2018/10/06/ji-yi-ci-macbook-pro-wu-fa-lian-jie-wifi-wang-luo-xiu-fu/</url>
      
        <content type="html"><![CDATA[<p>解决方案：<br><a href="https://blog.csdn.net/kimbing/article/details/79321001" target="_blank" rel="noopener">https://blog.csdn.net/kimbing/article/details/79321001</a><br>真的哭了<br>原因是插入了我的USB3.0拓展坞影响了wifi信号<br>不知道原理是啥 但是很神奇的是拔掉就正常了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
